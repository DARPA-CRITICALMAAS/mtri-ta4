# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GIDLaC
                                 A QGIS plugin
 This plugin aids in labelling data for Classification
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-08-15
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Jeremy Graham MTRI
        email                : jeremyg@mtu.edu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QTableWidgetItem, QDialog
from qgis.core import (QgsProject, QgsVectorLayer, QgsRasterLayer, QgsMapLayerProxyModel, QgsRasterShader,
                       QgsColorRampShader, QgsSingleBandPseudoColorRenderer, QgsPalettedRasterRenderer,
                       QgsFieldProxyModel)
from PyQt5.QtCore import QVariant
from qgis import processing

from time import sleep
import json
# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .gidlac_dockwidget import GIDLaCDockWidget


from .add_raster_layer_NoUi import AddRasterLayer


import os.path
try:
    import gdal
    import ogr
except ModuleNotFoundError:
    from osgeo import gdal
    from osgeo import ogr


try:
    from sklearn.cluster import MiniBatchKMeans
    from sklearn.decomposition import PCA
    from sklearn.preprocessing import StandardScaler
    from sklearn.model_selection import train_test_split
    from sklearn.ensemble import RandomForestClassifier
    from sklearn.metrics import confusion_matrix
    from sklearn.metrics import classification_report
    from sklearn.model_selection import StratifiedKFold
    from skimage import segmentation
    from skimage.filters import difference_of_gaussians
    from scipy import stats
    import numpy.matlib
    import pandas as pd
except ModuleNotFoundError:
    pass


import numpy as np
import rasterio as rio
import geopandas as gpd
from sklearn import svm
from shapely.geometry import box
from sklearn.ensemble import IsolationForest
from sklearn.neighbors import LocalOutlierFactor

import pydevd_pycharm

from plugins.gidlac.helperFuncs import *
from plugins.gidlac.dev.template_raster_user_input import *
from plugins.gidlac.dev.match_stack_raster_tools import *
from plugins.gidlac.dev.rasterize_training_data import *
from plugins.gidlac.dev.threshold_inference import *
from plugins.gidlac.dev.proximity_raster import *
from plugins.gidlac.dev.simple_CT_point_interpolation import *
from plugins.gidlac.dev.geo_chem.link_black_shales_db import *
from pathlib import Path
from datetime import date
import shutil
import json


globalVariables = dotDict(dict())

class GIDLaC:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.canvas = self.iface.mapCanvas()

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GIDLaC_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&GIDLaC')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'GIDLaC')
        self.toolbar.setObjectName(u'GIDLaC')

        #print "** INITIALIZING GIDLaC"

        self.pluginIsActive = False
        self.dockwidget = None

        # Objects for Add Layers panel
        self.pathlist = []
        self.methodlist = []
        self.desclist = []

        self.meta_data = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GIDLaC', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/gidlac/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING GIDLaC"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD GIDLaC"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&GIDLaC'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING GIDLaC"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = GIDLaCDockWidget()

                # self.AddRasterPopup = AddRasterLayer()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
            
            self.populate_comboboxes()
            self.runButtons()



    # --------------------------------------------------------------------------
    def populate_comboboxes(self):
        self.dockwidget.comboBox_raster.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.dockwidget.comboBox_vector.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.dockwidget.training_layer_combo_box.setFilters(QgsMapLayerProxyModel.VectorLayer)
        training_layer = self.dockwidget.training_layer_combo_box.currentLayer()
        if training_layer:
            self.dockwidget.trainingFieldComboBox.setLayer(training_layer)
            self.dockwidget.trainingFieldComboBox.setFilters(QgsFieldProxyModel.Numeric)

        self.dockwidget.mQgsProjectionSelectionWidget.setCrs(QgsCoordinateReferenceSystem('ESRI:102008'))

    def saveTrainingDataOut(self):
        filename = QFileDialog.getSaveFileName(self.dockwidget, self.tr("Select output file"), "", self.tr('*.csv'))[0] + '.csv'
        self.dockwidget.PrintBox.setText('Writing File')

        selectedLayer = self.dockwidget.comboBox_vector.currentLayer()
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()

        trainingList = []
        if self.dockwidget.withSelectedcheckBox.isChecked():
            sel = selectedLayer.selectedFeatures()
            for feat in sel:
                classLabel = feat['type_id']
                fid = feat['fid']
                plydat = ExtractRasterValuesFromSelectedFeature(selectedRas, selectedLayer, feat)
                plydatT = plydat.T
                cv = np.full((plydatT.shape[0], 1), classLabel)
                fv = np.full((plydatT.shape[0], 1), fid)
                ds = np.hstack([cv, fv, plydatT])
                trainingList.append(ds)
        else:
            features = selectedLayer.getFeatures()
            for feat in features:
                classLabel = feat['type_id']
                fid = feat['fid']
                plydat = ExtractRasterValuesFromSelectedFeature(selectedRas, selectedLayer, feat)
                plydatT = plydat.T
                cv = np.full((plydatT.shape[0], 1), classLabel)
                fv = np.full((plydatT.shape[0], 1), fid)
                ds = np.hstack([cv, fv, plydatT])
                trainingList.append(ds)

        cds = np.vstack(trainingList)
        # np.savetxt(filename, cds, delimiter=",")
        col_names = rasterBandDescAslist(selectedRas.source())
        col_names.insert(0, 'type_id')
        col_names.insert(1, 'fid')

        df = pd.DataFrame(data=cds, columns=col_names)
        df['type_id'] = df['type_id'].astype(int)
        df['fid'] = df['fid'].astype(int)
        df.to_csv(filename, index=False)


        self.dockwidget.PrintBox.setText(f'File Saved to {filename}')

    def fillStatBoxFromSelectedPoly(self):
        selectedLayer = self.dockwidget.comboBox_vector.currentLayer()
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        sel = selectedLayer.selectedFeatures()  # returns a list of selected features
        feat = sel[0]  # Returns the first QgsFeature
        dat = ExtractRasterValuesFromSelectedFeature(selectedRas, selectedLayer, feat)
        means = dat.mean(axis=1)
        stds = dat.std(axis=1)
        l = [[x, y] for x, y in zip(means, stds)]

        qTable = self.dockwidget.stats_table
        bdescs = rasterBandDescAslist(selectedRas.source())
        data = l
        nb_row = len(data)
        nb_col = 5
        qTable.setColumnCount(nb_col)
        qTable.setColumnWidth(0, 80)
        qTable.setColumnWidth(1, 50)
        qTable.setColumnWidth(2, 80)
        qTable.setColumnWidth(3, 50)
        qTable.setColumnWidth(4, 50)
        qTable.setHorizontalHeaderLabels([u'Band Name', u'Select', u'Mean', u'SD', u'Factor'])

        for (idx, dat), desc in zip(enumerate(data), bdescs):
            qTable.setItem(idx, 0, QTableWidgetItem(desc))
            qTable.setItem(idx, 1, QTableWidgetItem('1'))
            qTable.setItem(idx, 2, QTableWidgetItem(str(dat[0])))
            qTable.setItem(idx, 3, QTableWidgetItem(str(dat[1])))
            qTable.setItem(idx, 4, QTableWidgetItem(''))

    def RefreshBandSelection(self):
        qTable = self.dockwidget.stats_table
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        bandcount = gdal.Open(selectedRas.source()).RasterCount
        bdescs = rasterBandDescAslist(selectedRas.source())
        nb_row = bandcount
        qTable.setRowCount(nb_row)
        nb_col = 5
        qTable.setColumnCount(nb_col)
        qTable.setColumnWidth(0, 80)
        qTable.setColumnWidth(1, 50)
        qTable.setColumnWidth(2, 80)
        qTable.setColumnWidth(3, 50)
        qTable.setColumnWidth(4, 50)
        qTable.setHorizontalHeaderLabels([u'Band Name', u'Select', u'Mean', u'SD', u'Factor'])
        for row, desc in zip(range(nb_row), bdescs):
            qTable.setItem(row, 0, QTableWidgetItem(desc))
            qTable.setItem(row, 1, QTableWidgetItem('1'))

    def RefreshTable(self):
        qTable = self.dockwidget.stats_table
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        bandcount = gdal.Open(selectedRas.source()).RasterCount
        bdescs = rasterBandDescAslist(selectedRas.source())
        nb_row = bandcount
        qTable.setRowCount(nb_row)
        nb_col = 5
        qTable.setColumnCount(nb_col)
        qTable.setColumnWidth(0, 80)
        qTable.setColumnWidth(1, 50)
        qTable.setColumnWidth(2, 80)
        qTable.setColumnWidth(3, 50)
        qTable.setColumnWidth(4, 50)
        qTable.setHorizontalHeaderLabels([u'Band Name', u'Select', u'Mean', u'SD', u'Factor'])
        for row, desc in zip(range(nb_row), bdescs):
            qTable.setItem(row, 0, QTableWidgetItem(desc))
            qTable.setItem(row, 1, QTableWidgetItem('1'))
            qTable.setItem(row, 2, QTableWidgetItem(''))
            qTable.setItem(row, 3, QTableWidgetItem(''))
            qTable.setItem(row, 4, QTableWidgetItem(''))

    def applyStdReturnMatchLayer(self):
        selectedLayer = self.dockwidget.comboBox_vector.currentLayer()
        doClassIDfield(selectedLayer)

        sel = selectedLayer.selectedFeatures()
        feat = sel[0]
        classid = feat['type_id']
        fid = feat['Class_ID']
        layername = 'Class_' + str(classid) + '_CID_' + str(fid) + '_Manual_Matches'

        qTable = self.dockwidget.stats_table
        tabLen = qTable.rowCount()
        vallist = []
        # Here's where to Figure out what bands are selected
        # Could turn this into a function that just returns the value list, or list of bands to use
        for i in range(tabLen):
            if qTable.item(i,4).text():
                mean = float(qTable.item(i,2).text())
                std = float(qTable.item(i,3).text())
                multiplier = float(qTable.item(i,4).text())
                blist = [i+1, mean, std, std * multiplier]
                vallist.append(blist)
            else:
                print("Band not used")

        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        r_ds = gdal.Open(selectedRas.source())
        geot = r_ds.GetGeoTransform()
        r_proj = r_ds.GetProjection()

        ms = [RasMatcha(j, r_ds) for j in vallist]
        boolstack = np.vstack([ms])
        allmatch = np.all(boolstack, axis=0).astype(np.uint8)
        matchout = np.where(allmatch, classid, 0)

        savedLayer = gdalSave('bandStats_Match', matchout, gdal.GDT_Byte, geot, r_proj, 0)
        addLayerSymbol(savedLayer, layername, classid, "Classes")

    def constantSTdevMatch(self):
        selectedLayer = self.dockwidget.comboBox_vector.currentLayer()
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        r_ds = gdal.Open(selectedRas.source())
        geot = r_ds.GetGeoTransform()
        r_proj = r_ds.GetProjection()
        cellres = geot[1]

        doClassIDfield(selectedLayer)
        sel = selectedLayer.selectedFeatures()
        # Maybe here is where can do multiple selection if len(sel >1 ...
        feat = sel[0]  # Returns a QgsFeature
        # For naming the layer in the contents
        fid = feat['Class_ID']
        classid = feat['type_id']

        plydat = ExtractRasterValuesFromSelectedFeature(selectedRas, selectedLayer, feat)
        means = plydat.mean(axis=1)
        stds = plydat.std(axis=1)
        meanSTDlist = [[x, y] for x, y in zip(means, stds)]
        sdval = self.dockwidget.StdevInputBox1.value()
        numberBands2match = self.dockwidget.MinBandMatch.value()

        if self.dockwidget.ClusterWholeExtentBox.isChecked():
            layerName = 'Class_' + str(classid) + '_CID_' + str(fid) + '_' + str(sdval) + 'sdevs_Matches'

            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                idxs2keep = bands2indices(bandList)
                newmeans = np.array(meanSTDlist)[idxs2keep]
                dat = extractBands(bandList, r_ds)   # This is the dataset of which to find matches from
                matches = sdMatchSomeInStack(dat, newmeans, sdval, numberBands2match)

            else:
                dat = r_ds.ReadAsArray()
                matches = sdMatchSomeInStack(dat, meanSTDlist, sdval, numberBands2match)

        else:
            layerName = 'InWindow_Class_' + str(classid) + '_CID_' + str(fid) + '_' + str(sdval) + '_sdevs_Matches'

            bb = self.canvas.extent()
            bb.asWktCoordinates()
            bbc = [bb.xMinimum(), bb.yMinimum(), bb.xMaximum(), bb.yMaximum()]
            offsets = boundingBoxToOffsets(bbc, geot)
            new_geot = geotFromOffsets(offsets[0], offsets[2], geot)
            geot = new_geot

            sizeX = int(((bbc[2] - bbc[0]) / cellres) + 1)
            sizeY = int(((bbc[3] - bbc[1]) / cellres) + 1)

            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                dat = extractBandsInBounds(bandList, r_ds, offsets[2], offsets[0], sizeX, sizeY)
                idxs2keep = bands2indices(bandList)
                newmeans = np.array(meanSTDlist)[idxs2keep]
                matches = sdMatchSomeInStack(dat, newmeans, sdval, numberBands2match)
            else:
                dat = r_ds.ReadAsArray(offsets[2], offsets[0], sizeX, sizeY)
                matches = sdMatchSomeInStack(dat, meanSTDlist, sdval, numberBands2match)


        valued_to_typeVal = np.where(matches == 1, int(classid), 0)


        value = np.count_nonzero(valued_to_typeVal == int(classid))
        statement = f'Found {value} matches in Raster'
        if value > 1:
            self.dockwidget.PrintBox.setText(statement)
            savedLayer = gdalSave('stdevMatch_', valued_to_typeVal, gdal.GDT_Byte, geot, r_proj, 0)
            addLayerSymbol(savedLayer, layerName, classid, "Classes")

    def evaluteTrainingPolygons(self):
        '''
        Going to design this one to only work across the whole raster. This will be a slower more robust mat
        :return:
        '''
        selectedLayer = self.dockwidget.comboBox_vector.currentLayer()
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        r_ds = gdal.Open(selectedRas.source())
        geot = r_ds.GetGeoTransform()
        r_proj = r_ds.GetProjection()
        sdval = self.dockwidget.StdevInputBox1.value()

        evalstatement = 'Finding Matches for Polygons'
        print(evalstatement)
        self.dockwidget.PrintBox.setText(evalstatement)

        # Add and populate the classID column
        doClassIDfield(selectedLayer)

        sel = selectedLayer.selectedFeatures()
        if len(sel) > 1:
            vals = list(set([x['type_id'] for x in sel]))
            groupNames = ['Class_' + str(v) for v in vals]
            root = QgsProject.instance().layerTreeRoot()
            # Add the groups to the ToC
            for idx, group in enumerate(groupNames, 0):
                root.insertGroup(idx, group)
            lols = [[] for x in vals]  # to hold all the finds

            for feat in sel:
                # For naming the layer in the contents
                classID = feat['Class_ID']
                classLabel = feat['type_id']

                plydat = ExtractRasterValuesFromSelectedFeature(selectedRas, selectedLayer, feat)
                means = plydat.mean(axis=1)
                stds = plydat.std(axis=1)
                meanSTDlist = [[x, y] for x, y in zip(means, stds)]

                numberBands2match = self.dockwidget.MinBandMatch.value()

                layerName = 'Class_' + str(classLabel) + '_poly_' + str(classID) + '_sd_' + str(sdval) + '_Matches'

                if self.dockwidget.UseBandSelectionBox.isChecked():
                    bandList = bandSelToList(self.dockwidget.stats_table)
                    idxs2keep = bands2indices(bandList)
                    newmeans = np.array(meanSTDlist)[idxs2keep]
                    dat = extractBands(bandList, r_ds)  # This is the dataset of which to find matches from
                    matches = sdMatchSomeInStack(dat, newmeans, sdval, numberBands2match)

                else:
                    dat = r_ds.ReadAsArray()
                    matches = sdMatchSomeInStack(dat, meanSTDlist, sdval, numberBands2match)

                valued_to_typeVal = np.where(matches == 1, int(classLabel), 0)

                value = np.count_nonzero(valued_to_typeVal == int(classLabel))
                statement = f'Found {value} matches in Raster with Class {classLabel} and ID {classID}'
                if value > 1:
                    # Update this statement to include which polygon it is
                    self.dockwidget.PrintBox.setText(statement)
                    listIndex = vals.index(classLabel)
                    lols[listIndex].append(valued_to_typeVal)
                    savedLayer = gdalSave('stdevMatch_', valued_to_typeVal, gdal.GDT_Byte, geot, r_proj, 0)
                    group = root.findGroup('Class_' + str(classLabel))
                    addLayerSymbolGroup(savedLayer, layerName, classLabel, group, "Classes")
        else:
            vals = list(selectedLayer.uniqueValues(selectedLayer.fields().indexOf('type_id')))
            groupNames = ['Class_' + str(v) for v in vals]
            root = QgsProject.instance().layerTreeRoot()
            # Add the groups to the ToC
            for idx, group in enumerate(groupNames, 0):
                root.insertGroup(idx, group)
            # Consider this part only for doing all

            lols = [[] for x in vals]  # to hold all the finds

            features = selectedLayer.getFeatures()
            for feat in features:
                # For naming the layer in the contents
                classID = feat['Class_ID']
                classLabel = feat['type_id']

                plydat = ExtractRasterValuesFromSelectedFeature(selectedRas, selectedLayer, feat)
                means = plydat.mean(axis=1)
                stds = plydat.std(axis=1)
                meanSTDlist = [[x, y] for x, y in zip(means, stds)]

                numberBands2match = self.dockwidget.MinBandMatch.value()


                layerName = 'Class_' + str(classLabel) + '_poly_' + str(classID) + '_sd_' + str(sdval) + '_Matches'

                if self.dockwidget.UseBandSelectionBox.isChecked():
                    bandList = bandSelToList(self.dockwidget.stats_table)
                    idxs2keep = bands2indices(bandList)
                    newmeans = np.array(meanSTDlist)[idxs2keep]
                    dat = extractBands(bandList, r_ds)   # This is the dataset of which to find matches from
                    matches = sdMatchSomeInStack(dat, newmeans, sdval, numberBands2match)

                else:
                    dat = r_ds.ReadAsArray()
                    matches = sdMatchSomeInStack(dat, meanSTDlist, sdval, numberBands2match)

                valued_to_typeVal = np.where(matches == 1, int(classLabel), 0)

                value = np.count_nonzero(valued_to_typeVal == int(classLabel))
                statement = f'Found {value} matches in Raster with Class {classLabel} and ID {classID}'
                if value > 1:
                    # Update this statement to include which polygon it is
                    self.dockwidget.PrintBox.setText(statement)
                    listIndex = vals.index(classLabel)
                    lols[listIndex].append(valued_to_typeVal)
                    savedLayer = gdalSave('stdevMatch_', valued_to_typeVal, gdal.GDT_Byte, geot, r_proj, 0)
                    group = root.findGroup('Class_' + str(classLabel))
                    addLayerSymbolGroup(savedLayer, layerName, classLabel, group, "Classes")

        evalstatement1 = 'Looking at class overlaps'
        print(evalstatement1)
        self.dockwidget.PrintBox.setText(evalstatement1)

        # In this part do the within and cross class matching
        toCompareList, singClassList = createClassCoverageList(vals, lols)
        crossList = createCrossClassList(toCompareList)
        # crossList and singClassList have structure of: list of [the array, string of layerName, the Unique Value]
        # Make a group for SingClassList
        classCoverGroup = root.insertGroup(0, 'ClassCovers')
        for layer in singClassList:
            layerOut = gdalSave('InClassMatch', layer[0], gdal.GDT_UInt16, geot, r_proj, 0)
            addLayerSymbolMutliClassGroup(layerOut, layer[1], classCoverGroup, np.unique(layer[0]).tolist(), "Coverage")

        classIntersectGroup = root.insertGroup(0, 'ClassIntersections')
        for layer in crossList:
            layerOut = gdalSave('BetweenClass', layer[0], gdal.GDT_UInt16, geot, r_proj, 0)
            addLayerSymbolMutliClassGroup(layerOut, layer[1], classIntersectGroup,  np.unique(layer[0]).tolist(), "Intersection")

        evalstatement2 = 'Finished'
        print(evalstatement2)
        self.dockwidget.PrintBox.setText(evalstatement2)

    def returnBoreMatch(self):
        selectedLayer = self.dockwidget.comboBox_vector.currentLayer()
        doClassIDfield(selectedLayer)
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        r_ds = gdal.Open(selectedRas.source())
        geot = r_ds.GetGeoTransform()
        r_proj = r_ds.GetProjection()

        doingmatching = 'Finding Matches'
        print(doingmatching)
        self.dockwidget.PrintBox.setText(doingmatching)

        sel = selectedLayer.selectedFeatures()  # returns a list of selected features
        feat = sel[0]  # Returns a QgsFeature
        # For naming the layer in the contents
        fid = feat['Class_ID']
        classid = feat['type_id']
        layerName = 'Class_' + str(classid) + '_CID_' + str(fid) + '_Matches'

        dat = ExtractRasterValuesFromSelectedFeature(selectedRas, selectedLayer, feat)

        # Go through each band and get the min and max after removing min and max
        vallist = []
        for b, d in enumerate(dat, 1):
            band = b
            # narr = MinMaxPop(d)
            # olymax = np.max(narr)
            # olymin = np.min(narr)
            olymax = np.max(d)
            olymin = np.min(d)

            l = [band, olymin, olymax]
            vallist.append(l)

        ms = [RasBoreMatch(j, r_ds) for j in vallist]
        boolstack = np.vstack([ms])
        allmatch = np.all(boolstack, axis=0).astype(np.uint8)
        valued_to_typeVal = np.where(allmatch == 1, int(classid), 0)


        value = np.count_nonzero(valued_to_typeVal == int(classid))
        statement = f'Found {value} matches in Raster'
        self.dockwidget.PrintBox.setText(statement)
        savedLayer = gdalSave('rasbore_', valued_to_typeVal, gdal.GDT_Byte, geot, r_proj, 0)
        addLayerSymbol(savedLayer, layerName, classid, "Classes")

    def DetectNumberClusters(self):
        '''
        The entire of the raster extraction and saving out is from the CreateRasterFromMapExtent Function.
        Just in between is the Kmeans Clustering stuff
        :return:
        '''

        def find_Nclust(data, start=3, stop=20, show_plot=False):
            intertias = []
            for i in range(start, stop):
                print(i)
                km = MiniBatchKMeans(n_clusters=i, init='k-means++', random_state=101)
                km.fit(data)
                intertias.append(km.inertia_)
            # if show_plot:
            # plt.plot(intertias)
            # plt.show()
            # Copied from
            # https://stackoverflow.com/questions/2018178/finding-the-best-trade-off-point-on-a-curve
            nPoints = len(intertias)
            allCoord = np.vstack((range(nPoints), intertias)).T
            firstPoint = allCoord[0]
            lineVec = allCoord[-1] - allCoord[0]
            lineVecNorm = lineVec / np.sqrt(np.sum(lineVec ** 2))
            vecFromFirst = allCoord - firstPoint
            scalarProduct = np.sum(vecFromFirst * np.matlib.repmat(lineVecNorm, nPoints, 1), axis=1)
            vecFromFirstParallel = np.outer(scalarProduct, lineVecNorm)
            vecToLine = vecFromFirst - vecFromFirstParallel
            distToLine = np.sqrt(np.sum(vecToLine ** 2, axis=1))
            bestidx = np.argmax(distToLine)
            n_clust = bestidx + start + 1
            print("Data organizes into {} clusters".format(n_clust))
            return n_clust

        def subsetter(data, num_samp=1000000):
            datlen = data.shape[0]
            datdim = data.shape[1]
            datsize = datlen * datdim
            if datsize > 100000:
                # print("taking a subset of {} rows to sample for best cluster size".format(num_samp))
                return data[np.random.choice(data.shape[0], num_samp, replace=True)]
            else:
                return data

        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        r_ds = gdal.Open(selectedRas.source())
        geot = r_ds.GetGeoTransform()
        cellres = geot[1]
        nodata = r_ds.GetRasterBand(1).GetNoDataValue()

        if self.dockwidget.ClusterWholeExtentBox.isChecked():
            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList()
                dat = extractBands(bandList, r_ds)
            else:
                dat = r_ds.ReadAsArray()
            data_array = np.transpose(dat, (1, 2, 0))  # convert from bands, rows, columns to rows, cols, bands
            twoDshape = (data_array.shape[0] * data_array.shape[1], data_array.shape[2])
            rs_data = data_array.reshape(twoDshape)
            bool_arr = np.all(rs_data == nodata, axis=1)
            if np.count_nonzero(bool_arr == 1) < 1:
                pred_data  = rs_data
            else:
                idxr = bool_arr.reshape(rs_data.shape[0])
                pred_data = rs_data[idxr == 0, :]
            nclust = find_Nclust(subsetter(pred_data, num_samp=1000000), start=3, stop=20, show_plot=True)
            clustprintstatement = f'Data of the Full Raster best described in {nclust} clusters'

        else:
            bb = self.canvas.extent()
            bb.asWktCoordinates()

            bbc = [bb.xMinimum(), bb.yMinimum(), bb.xMaximum(), bb.yMaximum()]
            offsets = boundingBoxToOffsets(bbc, geot)

            sizeX = int(((bbc[2] - bbc[0]) / cellres) + 1)
            sizeY = int(((bbc[3] - bbc[1]) / cellres) + 1)

            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                dat = extractBandsInBounds(bandList, r_ds, offsets[2], offsets[0], sizeX, sizeY)
            else:
                dat = r_ds.ReadAsArray(offsets[2], offsets[0], sizeX, sizeY)

            data_array = np.transpose(dat, (1, 2, 0))  # convert from bands, rows, columns to rows, cols, bands
            twoDshape = (data_array.shape[0] * data_array.shape[1], data_array.shape[2])
            pred_data = data_array.reshape(twoDshape)
            nclust = find_Nclust(subsetter(pred_data, num_samp=1000000), start=3, stop=20, show_plot=True)
            clustprintstatement = f'Data in Extent best described in {nclust} clusters'

        self.dockwidget.PrintBox.setText(clustprintstatement)

    def selectKmeansData(self):
        data_sel = self.dockwidget.data_sel_box.currentIndex()
        print(data_sel)
        if data_sel == 0:
            self.doKmeansFull_Window()
        elif data_sel == 1:
            self.doMaskedKmeans()
        elif data_sel == 2:
            self.doTrainingPolyKmeans()
        else:
            print('invalid selection')

    def doKmeansFull_Window(self):
        '''
        This function does the Kmeans on the full extent of the raster or window
        :return:
        '''
        # Print Statements
        doingClusters = 'Running Kmeans'
        print(doingClusters)
        self.dockwidget.PrintBox.setText(doingClusters)

        # Gather Inputs
        data_ras = self.dockwidget.comboBox_raster.currentLayer()
        nclust = self.dockwidget.NumClusterBox.value()
        varexp = self.dockwidget.pca_var_exp.value()
        pca_bool = self.dockwidget.PCAbox.isChecked()

        # Open the data raster and get metadata
        r_ds = gdal.Open(data_ras.source())
        ras_dict = getFullRasterDict(r_ds)
        rasBands = rasterBandDescAslist(data_ras.source())


        # Arrange the data from the whole raster or canvas extent into pixel feature format
        if self.dockwidget.ClusterWholeExtentBox.isChecked():
            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                rasBands = [rasBands[i-1] for i in bandList]
                dat = extractBands(bandList, r_ds)
            else:
                dat = r_ds.ReadAsArray()
        else:
            bb = self.canvas.extent()
            ras_dict = getCanvasRasterDict(ras_dict, bb)
            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                rasBands = [rasBands[i - 1] for i in bandList]
                dat = extractBandsInBounds(bandList, r_ds, ras_dict['Xoffset'], ras_dict['Yoffset'], ras_dict['sizeX'], ras_dict['sizeY'])
            else:
                dat = r_ds.ReadAsArray(ras_dict['Xoffset'], ras_dict['Yoffset'], ras_dict['sizeX'], ras_dict['sizeY'])

        data_array = np.transpose(dat, (1, 2, 0))  # convert from bands, rows, columns to rows, cols, bands
        twoDshape = (data_array.shape[0] * data_array.shape[1], data_array.shape[2])
        pred_data = data_array.reshape(twoDshape)
        bool_arr = np.any(pred_data == ras_dict['NoData'], axis=1)

        kosher({'pred_data': pred_data, 'bool_arr': bool_arr, 'nd': ras_dict['NoData']},
               '/home/jagraham/Documents/temp_work/temp_space/kmeans')

        labels, km, pca, fitdat = doPCA_kmeans(pred_data, bool_arr, nclust, varexp, pca_bool)
        fullK_dict = {'labels': labels, 'km': km, 'pca': pca, 'ras_dict': ras_dict, 'fitdat': fitdat,
                      'bool_arr': bool_arr, 'rasBands': rasBands, 'nclust': nclust}

        globalVariables['fullK'] = fullK_dict
        print('added to gvars')

    def NewMapClusters(self):
        if not globalVariables['fullK']:
            print('need to run Kmeans first')
        labels1, km, pca, ras_dict, bool_arr, fitdat, rasBands, nclust = unpack_fullK(globalVariables['fullK'])

        if self.dockwidget.ArchetypeCheckBox.isChecked():
            classout, labels = placeLabels_inRaster(labels1, bool_arr, ras_dict, 'uint8', return_labels=True)
        else:
            classout = placeLabels_inRaster(labels1, bool_arr, ras_dict, 'uint8')

        #
        # labels = np.zeros_like(bool_arr).astype('uint8')
        # labels[~bool_arr] = labels1
        # labels[bool_arr] = 0
        #
        # preds = labels.reshape(ras_dict['sizeY'], ras_dict['sizeX'], 1)
        # classout = np.transpose(preds, (0, 1, 2))[:, :, 0]

        root = QgsProject.instance().layerTreeRoot()
        layerName = 'Kmeans_' + str(nclust) + '_clusters'

        if root.findGroup('Kmeans') == None:
            Kgroup = root.insertGroup(0, 'Kmeans')
        else:
            Kgroup = root.findGroup('Kmeans')

        savedLayer = gdalSave('Window_Kmeans_', classout, gdal.GDT_Byte, ras_dict['GeoTransform'], ras_dict['Projection'], 0)
        addLayerSymbolMutliClassGroup(savedLayer, layerName, Kgroup, np.unique(classout).tolist(), "Classes")

        if self.dockwidget.ArchetypeCheckBox.isChecked():
            conflevel = float(self.dockwidget.ConfValue.text())
            fuzzval = float(self.dockwidget.FuzzinessValue.text())
            weights = soft_clustering_weights(fitdat, km.cluster_centers_, fuzzval)
            conf = np.max(weights, axis=1).astype('float32')

            if conf.shape[0] == labels.shape[0]:
                best_clusts = np.where(conf > conflevel, labels, 0).astype('uint8')
            else:
                # need to use the mask to fill in values
                new_conf = np.zeros_like(bool_arr).astype('float32')
                new_conf[~bool_arr] = conf
                new_conf[bool_arr] = 0
                best_clusts = np.where(new_conf > conflevel, labels, 0).astype('uint8')

            # bestsout = best_clusts.reshape(data_array.shape[0], data_array.shape[1])
            bestsout = best_clusts.reshape(ras_dict['sizeY'], ras_dict['sizeX'])
            confLayerName = 'Conf_' + str(conflevel).split(".")[1] + "_" + str(fuzzval)
            savedConf = gdalSave('Conf_', bestsout, gdal.GDT_Byte, ras_dict['GeoTransform'], ras_dict['Projection'], 0)
            addLayerSymbolMutliClassGroup(savedConf, confLayerName, Kgroup, np.unique(classout).tolist(), "Classes")

    def doMaskedKmeans(self):
        # Get inputs
        data_ras = self.dockwidget.comboBox_raster.currentLayer()
        class_ras = self.dockwidget.comboBox_ClassRaster.currentLayer()
        nclust = self.dockwidget.numNewClustersBox.value()
        inputClasses = self.dockwidget.class_parse_lineEdit.text()
        varexp = self.dockwidget.pca_var_exp.value()
        pca_bool = self.dockwidget.PCAbox.isChecked()
        clusclass = [int(x) for x in inputClasses.split(',')]

        # Open the data raster and get metadata
        r_ds = gdal.Open(data_ras.source())
        ras_dict = getFullRasterDict(r_ds)
        rasBands = rasterBandDescAslist(data_ras.source())

        # Open the class raster
        classRaster = gdal.Open(class_ras.source())
        print(classRaster)

        # Arrange the data from the whole raster or canvas extent into pixel feature format
        if self.dockwidget.ClusterWholeExtentBox.isChecked():
            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                rasBands = [rasBands[i - 1] for i in bandList]
                stack_arr = extractBands(bandList, r_ds)
            else:
                stack_arr = r_ds.ReadAsArray()
            class_arr = classRaster.ReadAsArray()
        else:

            bb = self.canvas.extent()
            ras_dict = getCanvasRasterDict(ras_dict, bb)
            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                rasBands = [rasBands[i - 1] for i in bandList]
                stack_arr = extractBandsInBounds(bandList, r_ds, ras_dict['Xoffset'], ras_dict['Yoffset'], ras_dict['sizeX'],
                                           ras_dict['sizeY'])
            else:
                stack_arr = r_ds.ReadAsArray(ras_dict['Xoffset'], ras_dict['Yoffset'], ras_dict['sizeX'], ras_dict['sizeY'])


            # This is jank. should put in a if canvas extent is smaller than the class raster then use the window read
            class_arr = classRaster.ReadAsArray()
            # class_arr = classRaster.ReadAsArray(ras_dict['Xoffset'], ras_dict['Yoffset'], ras_dict['sizeX'], ras_dict['sizeY'])



        if len(class_arr.shape) == 2:
            class_arr = np.expand_dims(class_arr, axis=0)


        print(f'class_arr shape {class_arr.shape}')
        print(f'stack_arr shape {stack_arr.shape}')
        re_class = np.transpose(class_arr, (1, 2, 0))
        re_stack = np.transpose(stack_arr, (1, 2, 0))

        twoDshape = (re_stack.shape[0] * re_stack.shape[1], re_stack.shape[2])

        pred_data = re_stack.reshape(twoDshape)
        class_data = re_class.reshape(twoDshape[0])

        nodata_mask = np.any(pred_data == ras_dict['NoData'], axis=1)

        print(f'class shape {class_data.shape}')
        print(f'pred shape {pred_data.shape}')

        labels, km, pca, fitdat, bool_arr = clusterDataInMask(pred_data, class_data, nodata_mask, nclust, varexp, pca_bool, clusclass)

        maskK_dict = {'labels': labels, 'km': km, 'pca': pca, 'ras_dict': ras_dict, 'fitdat': fitdat,
                      'bool_arr': bool_arr, 'rasBands': rasBands, 'nclust': nclust, 'class_arr': class_arr}
        globalVariables['maskK'] = maskK_dict
        print('added to gvars')

        # if perclass_bool:
        #     print('do per class')
        #     # Make mask to block out nodata
        #     outclassList = []
        #     for cls in clusclass:
        #         noncluster_mask = np.isin(class_data, cls, invert=True)
        #         bool_arr = np.logical_or(noncluster_mask, nodata_mask)
        #         outclass = clusterDataInMask(pred_data, bool_arr, nclust, varexp, rsizeY, rsizeX)
        #         newValarr = np.where(outclass != 0, outclass + (cls * 10), 0)
        #         outclassList.append(newValarr)
        #     classout = sum(outclassList)
        # else:
        #     print('do pooled classes')
        #     noncluster_mask = np.isin(class_data, clusclass, invert=True)
        #     bool_arr = np.logical_or(noncluster_mask, nodata_mask)
        #     classout, fitdat, labels, km = clusterDataInMask(pred_data, bool_arr, nclust, rsizeY, rsizeX)
        #

    def mapMaskedClusters(self):
        if not globalVariables['maskK']:
            print('need to run Kmeans first')
        labels1, km, pca, ras_dict, bool_arr, fitdat, rasBands, nclust, class_arr = unpack_fullK(globalVariables['maskK'])

        if self.dockwidget.ArchetypeCheckBox.isChecked():
            classout, labels = placeLabels_inRaster(labels1, bool_arr, ras_dict, 'uint8', return_labels=True)
        else:
            classout = placeLabels_inRaster(labels1, bool_arr, ras_dict, 'uint8')

        burnOver = self.dockwidget.burnBox.isChecked()
        inputClasses = self.dockwidget.class_parse_lineEdit.text()
        clusclass = [int(x) for x in inputClasses.split(',')]

        layerName = 'Class_' + inputClasses + 'into' + str(nclust) + '_Classes'

        if burnOver:
            print('burning new clusters over classified map')
            class_mask = np.isin(class_arr[0, :, :], clusclass)
            classout = np.where(class_mask, classout, class_arr[0, :, :])

        root = QgsProject.instance().layerTreeRoot()
        if root.findGroup('Kmeans') == None:
            Kgroup = root.insertGroup(0, 'Kmeans')
        else:
            Kgroup = root.findGroup('Kmeans')

        savedLayer = gdalSave('Window_Kmeans_', classout, gdal.GDT_Byte, ras_dict['GeoTransform'], ras_dict['Projection'], 0)
        addLayerSymbolMutliClassGroup(savedLayer, layerName, Kgroup, np.unique(classout).tolist(), "Classes")

        if self.dockwidget.ArchetypeCheckBox.isChecked():
            conflevel = float(self.dockwidget.ConfValue.text())
            fuzzval = float(self.dockwidget.FuzzinessValue.text())
            weights = soft_clustering_weights(fitdat, km.cluster_centers_, fuzzval)
            conf = np.max(weights, axis=1).astype('float32')

            if conf.shape[0] == labels.shape[0]:
                best_clusts = np.where(conf > conflevel, labels, 0).astype('uint8')
            else:
                # need to use the mask to fill in values
                new_conf = np.zeros_like(bool_arr).astype('float32')
                new_conf[~bool_arr] = conf
                new_conf[bool_arr] = 0
                best_clusts = np.where(new_conf > conflevel, labels, 0).astype('uint8')

            bestsout = best_clusts.reshape(ras_dict['sizeY'], ras_dict['sizeX'])
            confLayerName = 'Conf_' + str(conflevel).split(".")[1] + "_" + str(fuzzval)
            savedConf = gdalSave('Conf_', bestsout, gdal.GDT_Byte, ras_dict['GeoTransform'], ras_dict['Projection'], 0)
            addLayerSymbolMutliClassGroup(savedConf, confLayerName, Kgroup, np.unique(classout).tolist(), "Classes")

        doneClusters = 'Finished Mapping Clusters '
        print(doneClusters)
        self.dockwidget.PrintBox.setText(doneClusters)

    def doTrainingPolyKmeans(self):
        selectedLayer = self.dockwidget.comboBox_vector.currentLayer()
        data_ras = self.dockwidget.comboBox_raster.currentLayer()
        retain_pct = float(self.dockwidget.TestHoldPct_spinBox.value()) / 100

        samplingRate = self.dockwidget.samplingRatespinBox.value()
        maxPixPoly = self.dockwidget.max_pix_poly_spinBox.value()
        maxClassPix = self.dockwidget.max_sample_spinBox.value()

        nclust = self.dockwidget.NumClusterBox.value()
        varexp = self.dockwidget.pca_var_exp.value()
        pca_bool = self.dockwidget.PCAbox.isChecked()

        r_ds = gdal.Open(data_ras.source())
        ras_dict = getFullRasterDict(r_ds)
        rasBands = rasterBandDescAslist(data_ras.source())

        trainingstarting = 'Training Model'
        print(trainingstarting)
        self.dockwidget.PrintBox.setText(trainingstarting)

        if self.dockwidget.withSelectedcheckBox.isChecked():
            train_dat = getTrainingDataFromFeatures(data_ras, selectedLayer, withSelected=True,
                                                    samplingRate=samplingRate, maxPerPoly=maxPixPoly)
        else:
            train_dat = getTrainingDataFromFeatures(data_ras, selectedLayer, withSelected=False,
                                                    samplingRate=samplingRate, maxPerPoly=maxPixPoly)

        bands = rasterBandDescAslist(data_ras.source())

        if self.dockwidget.UseBandSelectionBox.isChecked():
            train_dat, bands = dropSelectedBandsforSupClass(train_dat, bandSelToList(self.dockwidget.stats_table),
                                                            bands)

        if self.dockwidget.lowestSample_CheckBox.isChecked():
            train_dat = balancedSamples(train_dat, take_min=True, n=maxClassPix)
        else:
            train_dat = balancedSamples(train_dat, take_min=False, n=maxClassPix)

        bool_arr = np.any(train_dat == ras_dict['NoData'], axis=1)

        labels, km, pca, fitdat = doPCA_kmeans(train_dat, bool_arr, nclust, varexp, pca_bool)
        k_dict = {'labels': labels, 'km': km, 'pca': pca, 'ras_dict': ras_dict, 'fitdat': fitdat,
                      'bool_arr': bool_arr, 'rasBands': rasBands, 'nclust': nclust}
        globalVariables['trainingK'] = k_dict
        print('added to gvars')

        return None

    def makeTempLayer(self):
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        r_ds = gdal.Open(selectedRas.source())
        r_proj = r_ds.GetProjection()
        makeTempLayer(r_proj)

    def runPCAtrainingPointplot(self):

        df = globalVariables['point_samples']

        nclust = self.dockwidget.NumClusterBox.value()
        varexp = self.dockwidget.pca_var_exp.value()
        pca_bool = self.dockwidget.PCAbox.isChecked()

        km = MiniBatchKMeans(n_clusters=nclust, init='k-means++', random_state=101)
        pca = PCA(n_components=varexp, svd_solver='full')

        pred_data = df.to_numpy()

        standata = StandardScaler().fit_transform(pred_data)
        fitdat = pca.fit_transform(standata)
        print(f'PCA uses {pca.n_components_} to get to {varexp} variance explained')
        km.fit_predict(fitdat)
        labels = km.labels_ + 1

        # This is just to make doPCA_kmeans have something
        rasBands = df.columns
        bool_arr = np.array([0])
        if np.count_nonzero(bool_arr == 1) < 1:
            print(True)
        # ras_dict =


        data_input = {'labels': labels, 'km': km, 'pca': pca, 'ras_dict': ras_dict, 'fitdat': fitdat,
                      'bool_arr': bool_arr, 'rasBands': rasBands, 'nclust': nclust}



        k_dict = {'labels': labels, 'km': km, 'pca': pca, 'ras_dict': ras_dict, 'fitdat': fitdat,
                  'bool_arr': bool_arr, 'rasBands': rasBands, 'nclust': nclust}
        globalVariables['trainingK'] = k_dict

    def runPCAplot(self):
        pca_axis_1 = self.dockwidget.plt_axis_1.value()
        pca_axis_2 = self.dockwidget.plt_axis_2.value()
        pct_data_plot = self.dockwidget.pctdataplotBox.value()
        plotsubVal = int(100 / pct_data_plot)
        data_sel = self.dockwidget.data_sel_box.currentIndex()
        print(data_sel)
        if data_sel == 0:
            data_input = globalVariables['fullK']
        elif data_sel == 1:
            data_input = globalVariables['maskK']
        elif data_sel == 2:
            data_input = globalVariables['trainingK']
        else:
            print('invalid selection')
        if data_input:
            makePCAplot(data_input, pca_axis_1, pca_axis_2, plotsubVal, data_sel)

    def makeSpectralPlot(self):
        selectedLayer = self.dockwidget.comboBox_vector.currentLayer()
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()

        trainingList = []
        sel = selectedLayer.selectedFeatures()
        for feat in sel:
            classLabel = feat['type_id']
            fid = feat['fid']
            plydat = ExtractRasterValuesFromSelectedFeature(selectedRas, selectedLayer, feat)
            plydatT = plydat.T
            cv = np.full((plydatT.shape[0], 1), classLabel)
            fv = np.full((plydatT.shape[0], 1), fid)
            ds = np.hstack([cv, fv, plydatT])
            trainingList.append(ds)

        cds = np.vstack(trainingList)
        # Might need to add in a clause to use default names if this doesn't work
        col_names = rasterBandDescAslist(selectedRas.source())
        col_names.insert(0, 'type_id')
        col_names.insert(1, 'fid')

        df = pd.DataFrame(data=cds, columns=col_names)
        df['type_id'] = df['type_id'].astype(int)
        df['fid'] = df['fid'].astype(int)

        # The balanced samples can be an option at some point
        # Need to make a checkbox
        # trimmed_df = balancedSamples(df, 'type_id', False, 1500)

        inputbands = self.dockwidget.PrintBox.text()
        try:
            plot_cols = [(int(x) + 1) for x in inputbands.split(',')]  # +1 since fid is added in
        except ValueError:
            plot_cols = [2,3,4]
        print(plot_cols)
        plot_cols.insert(0, 0)
        plot_cols.insert(1, 1)

        # plot_df = trimmed_df.iloc[:, plot_cols]  # If trimmed
        plot_df = df.iloc[:, plot_cols]

        # print("Plot_DF =\n", plot_df.head())

        ## Example in case want to do a class selection as well
        # plot_classes = [2, 4, 5, 9]
        # plot_df = df_colsub.loc[df_colsub.type_id.isin(plot_classes)]

        tfol = tempfile.mkdtemp()  # maybe this should be done globally at the init??
        plotfile = Path(tempfile.mkstemp(dir=tfol, suffix='.png', prefix='specPlot_')[1])
        # multispec_scatter_original(plot_df, plotfile)
        multispec_scatter(plot_df, plotfile)

    def summarize_training(self):
        selectedLayer = self.dockwidget.comboBox_vector.currentLayer()
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        samplingRate = self.dockwidget.samplingRatespinBox.value()
        maxPixPoly = self.dockwidget.max_pix_poly_spinBox.value()
        print("TRAINING SUMMARY")

        train_dat = getTrainingDataFromFeatures(selectedRas, selectedLayer, withSelected=False, samplingRate=samplingRate, maxPerPoly=maxPixPoly)
        labels = train_dat[:, 0]
        summary = label_count(labels)
        print(summary)

    def selectRFtrainPixel(self):
        num_folds = self.dockwidget.numKfoldsBox.value()
        if num_folds > 1:
            print(f"doing {num_folds} folds")
            self.buildRFmodelPixel_Kfolds()
        else:
            print("Doing one off validation")
            self.buildRFmodelPixelNoFold()

    def selectRFapplyPixel(self):
        num_iters = self.dockwidget.numKfoldsBox.value()
        if num_iters > 1:
            self.applyRFpreds_PixelFolded()
        else:
            self.applyRFpreds_PixelNoFold()

    def buildRFmodelPixelNoFold(self):
        selectedLayer = self.dockwidget.comboBox_vector.currentLayer()
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        retain_pct = float(self.dockwidget.TestHoldPct_spinBox.value()) / 100

        samplingRate = self.dockwidget.samplingRatespinBox.value()
        maxPixPoly = self.dockwidget.max_pix_poly_spinBox.value()
        maxClassPix = self.dockwidget.max_sample_spinBox.value()
        njobs = self.dockwidget.njob_box.value()

        trainingstarting = 'Training Model'
        print(trainingstarting)
        self.dockwidget.PrintBox.setText(trainingstarting)

        if self.dockwidget.withSelectedcheckBox.isChecked():
            train_dat = getTrainingDataFromFeatures(selectedRas, selectedLayer, withSelected=True, samplingRate=samplingRate, maxPerPoly=maxPixPoly)
        else:
            train_dat = getTrainingDataFromFeatures(selectedRas, selectedLayer, withSelected=False, samplingRate=samplingRate, maxPerPoly=maxPixPoly)

        bands = rasterBandDescAslist(selectedRas.source())

        if self.dockwidget.UseBandSelectionBox.isChecked():
            train_dat, bands = dropSelectedBandsforSupClass(train_dat, bandSelToList(self.dockwidget.stats_table), bands)

        if self.dockwidget.lowestSample_CheckBox.isChecked():
            train_dat = balancedSamples(train_dat, take_min=True, n=maxClassPix)
        else:
            train_dat = balancedSamples(train_dat, take_min=False, n=maxClassPix)

        labels = train_dat[:, 0]
        features = train_dat[:, 1:train_dat.shape[0]]
        train_features, test_features, train_labels, test_labels = \
            train_test_split(features, labels, test_size=retain_pct)
        if self.dockwidget.custom_RF_checkBox.isChecked():
            print("using custom parameters")
            n_estimates = self.dockwidget.n_estimators_spinBox.value()
            maxfeatures = self.dockwidget.max_features_comboBox.currentText()
            max_dpth = self.dockwidget.max_depth_spinBox.value()
            min_samp_split = self.dockwidget.min_sample_spinBox_2.value()
            rfmod = RandomForestClassifier(n_estimators=n_estimates, max_depth=max_dpth, max_features=maxfeatures,
                                           min_samples_split=min_samp_split, n_jobs=njobs)
        else:
            rfmod = RandomForestClassifier(n_jobs=njobs)

        rfmod.fit(train_features, train_labels)

        globalVariables['pixel_rfmodel'] = rfmod

        trainingdone = 'Model Training Finished'
        print(trainingdone)
        self.dockwidget.PrintBox.setText(trainingdone)

        if self.dockwidget.errors_CheckBox.isChecked() or self.dockwidget.Conf_Checkbox.isChecked() or \
                self.dockwidget.Conf_Checkbox.isChecked():
            y_pred = rfmod.predict(test_features)


        if self.dockwidget.errors_CheckBox.isChecked():
            print(' -------------- Classification Report ------------------')
            print('                                            ')
            print(classification_report(test_labels, y_pred, labels=list(np.unique((train_labels).astype('uint8')))))
            print('                                            ')

        if self.dockwidget.Conf_Checkbox.isChecked():
            print(' ---------- Confusion Matrix -------------')
            print('                                            ')
            cm = confusion_matrix(test_labels, y_pred)
            globalVariables['valset'] = {'actual': test_labels, 'predicted': y_pred}
            cmdf = pd.DataFrame(cm, columns=list(np.unique((train_labels).astype('uint8'))))
            cmdf.index = list(np.unique((train_labels).astype('uint8')))
            print(cmdf)

            print('                                                            ')

        if self.dockwidget.BandImportance_CheckBox.isChecked():
            print(' --------- Band Importance -----------------')
            print('                                            ')
            importances = list(rfmod.feature_importances_)  # List of tuples with variable and importance
            feature_importances = [(feature, round(importance, 2)) for feature, importance in
                                   zip(bands, importances)]  # Sort the feature importances by most important first
            feature_importances = sorted(feature_importances, key=lambda x: x[1],
                                         reverse=True)  # Print out the feature and importances
            for fi in feature_importances:
                print('{:15} Importance: {}'.format(*fi))

    def buildRFmodelPixel_Kfolds(self):
        selectedLayer = self.dockwidget.comboBox_vector.currentLayer()
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        num_folds = self.dockwidget.numKfoldsBox.value()
        samplingRate = self.dockwidget.samplingRatespinBox.value()
        maxPixPoly = self.dockwidget.max_pix_poly_spinBox.value()
        retain_pct = self.dockwidget.TestHoldPct_spinBox.value()
        maxClassPix = self.dockwidget.max_sample_spinBox.value()
        njobs = self.dockwidget.njob_box.value()

        trainingstarting = 'Training Model'
        print(trainingstarting)
        self.dockwidget.PrintBox.setText(trainingstarting)

        if self.dockwidget.withSelectedcheckBox.isChecked():
            train_dat = getTrainingDataFromFeatures(selectedRas, selectedLayer, withSelected=True,
                                                    samplingRate=samplingRate, maxPerPoly=maxPixPoly)
        else:
            train_dat = getTrainingDataFromFeatures(selectedRas, selectedLayer, withSelected=False,
                                                    samplingRate=samplingRate, maxPerPoly=maxPixPoly)

        bands = rasterBandDescAslist(selectedRas.source())

        if self.dockwidget.UseBandSelectionBox.isChecked():
            train_dat, bands = dropSelectedBandsforSupClass(train_dat, bandSelToList(self.dockwidget.stats_table), bands)

        if self.dockwidget.lowestSample_CheckBox.isChecked():
            train_dat = balancedSamples(train_dat, take_min=True, n=maxClassPix)
        else:
            train_dat = balancedSamples(train_dat, take_min=False, n=maxClassPix)



        train_dat, valdat = randomSample(train_dat, retain_pct)

        y = train_dat[:, 0]
        X = train_dat[:, 1:]

        skf = StratifiedKFold(n_splits=num_folds)
        skf.get_n_splits(X, y)

        band_imp_list = []
        # could append the test_labels and y_preds instead, then calculate error mat and class report on those
        test_label_list = []
        y_pred_list = []
        rfmod_list = []

        fold_count = 1
        for train_index, test_index in skf.split(X, y):
            print(f"Fold # {fold_count}")
            fold_count += 1
            x_train_fold, x_test_fold = X[train_index], X[test_index]
            y_train_fold, y_test_fold = y[train_index], y[test_index]

            if self.dockwidget.custom_RF_checkBox.isChecked():
                print("using custom parameters")
                n_estimates = self.dockwidget.n_estimators_spinBox.value()
                maxfeatures = self.dockwidget.max_features_comboBox.currentText()
                max_dpth = self.dockwidget.max_depth_spinBox.value()
                min_samp_split = self.dockwidget.min_sample_spinBox_2.value()
                rfmod = RandomForestClassifier(n_estimators=n_estimates, max_depth=max_dpth, max_features=maxfeatures,
                                               min_samples_split=min_samp_split, n_jobs=njobs)
            else:
                rfmod = RandomForestClassifier(n_jobs=njobs)

            rfmod.fit(x_train_fold, y_train_fold)
            y_pred = rfmod.predict(x_test_fold)

            band_imp_list.append(rfmod.feature_importances_)
            test_label_list.append(y_test_fold)
            y_pred_list.append(y_pred)
            rfmod_list.append(rfmod)


            if self.dockwidget.errors_CheckBox.isChecked():
                print(' -------------- Classification Report ------------------')
                print('                                            ')
                print(
                    classification_report(y_test_fold, y_pred, labels=list(np.unique((y_train_fold).astype('uint8')))))
                print('                                            ')

            if self.dockwidget.Conf_Checkbox.isChecked():
                print(' ---------- Confusion Matrix -------------')
                print('                                            ')
                cm = confusion_matrix(y_test_fold, y_pred)
                cmdf = pd.DataFrame(cm, columns=list(np.unique((y_train_fold).astype('uint8'))))
                cmdf.index = list(np.unique((y_train_fold).astype('uint8')))
                print(cmdf)
                print('                                                            ')
                # error_mat_list.append(cm)

            if self.dockwidget.BandImportance_CheckBox.isChecked():
                print(' --------- Band Importance -----------------')
                print('                                            ')
                importances = list(rfmod.feature_importances_)  # List of tuples with variable and importance
                feature_importances = [(feature, round(importance, 2)) for feature, importance in
                                       zip(bands, importances)]  # Sort the feature importances by most important first
                feature_importances = sorted(feature_importances, key=lambda x: x[1],
                                             reverse=True)  # Print out the feature and importances
                for fi in feature_importances:
                    print('{:15} Importance: {}'.format(*fi))

            print(f"############# END FOLD {fold_count}  ################################")

        folded_y_preds = np.concatenate(y_pred_list)
        folded_test_labels = np.concatenate(test_label_list)

        cm = (confusion_matrix(folded_test_labels, folded_y_preds) / num_folds).astype('uint16')

        cmdf = pd.DataFrame(cm, columns=list(np.unique((y).astype('uint8'))))
        cmdf.index = list(np.unique((y).astype('uint8')))
        print("########################################################################")
        print(f"############### AVERAGED ERROR MATRIX FROM {num_folds} FOLDS ################")
        print("########################################################################")
        print(cmdf)
        print('___________________________________________________')

        print(f"############### AVERAGED CLASSIFICATION REPORT FROM {num_folds} FOLDS ################")
        print(classification_report(folded_test_labels, folded_y_preds,
                                    labels=list(np.unique((y).astype('uint8')))))
        print('___________________________________________________')
        print(f"############### TOP BAND IMPORTANCES FROM AVERAGED  {num_folds} FOLDS ################")
        imps = np.vstack(band_imp_list).T
        ave_imp = np.mean(imps, axis=1)

        feature_importances = [(feature, round(importance, 2)) for feature, importance in
                               zip(bands, ave_imp)]  # Sort the feature importances by most important first
        feature_importances = sorted(feature_importances, key=lambda x: x[1],
                                     reverse=True)  # Print out the feature and importances

        for fi in feature_importances:
            print('{:15} Importance: {}'.format(*fi))

        globalVariables['pixel_rfmodel_list'] = rfmod_list

        print("------------------------------------------------------------------------------")
        print(f"############### VALIDATION FROM WITHHELD SAMPLES ################")
        print("-------------------------------------------------------------------------------")

        val_y, val_x = valdat[:, 0], valdat[:, 1:]
        pred_list = []
        for rfmodel in rfmod_list:
            val_pred = rfmodel.predict(val_x)
            pred_list.append(val_pred)

        predarr = np.stack(pred_list)
        mode = stats.mode(predarr)
        mode_pred = mode[0][0, :]
        cm = confusion_matrix(val_y, mode_pred)
        globalVariables['valset'] = {'actual': val_y, 'predicted': mode_pred}
        cmdf = pd.DataFrame(cm, columns=list(np.unique((val_y).astype('uint8'))))
        cmdf.index = list(np.unique((val_y).astype('uint8')))
        print(cmdf)

        print('---------')

        print(classification_report(val_y, mode_pred, labels=list(np.unique(val_y).astype('uint8'))))

    def applyRFpreds_PixelNoFold(self):
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()

        root = QgsProject.instance().layerTreeRoot()
        if root.findGroup('RF_predicts') == None:
            RFgroup = root.insertGroup(0, 'RF_predicts')
        else:
            RFgroup = root.findGroup('RF_predicts')

        r_ds = gdal.Open(selectedRas.source())
        geot = r_ds.GetGeoTransform()
        r_proj = r_ds.GetProjection()
        nodata = r_ds.GetRasterBand(1).GetNoDataValue()
        cellres = geot[1]
        rsizeX, rsizeY = r_ds.RasterXSize, r_ds.RasterYSize

        rfmod = globalVariables['pixel_rfmodel']

        class_labels = list(rfmod.classes_)
        class_idxs = list(range(len(class_labels)))
        class_map_dict = dict(zip(class_idxs, class_labels))

        predstarting = 'Making Predictions'
        print(predstarting)
        self.dockwidget.PrintBox.setText(predstarting)

        if self.dockwidget.ClusterWholeExtentBox.isChecked():
            layerName = 'Full_Extent_' + 'RF'

            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                dat = extractBands(bandList, r_ds)
            else:
                dat = r_ds.ReadAsArray()

            data_array = np.transpose(dat, (1, 2, 0))  # convert from bands, rows, columns to rows, cols, bands
            twoDshape = (data_array.shape[0] * data_array.shape[1], data_array.shape[2])
            pred_data = data_array.reshape(twoDshape)
            bool_arr = np.all(pred_data == nodata, axis=1)
            if np.count_nonzero(bool_arr == 1) < 1:
                print('not over no data values')
                probs = rfmod.predict_proba(pred_data) * 100  # Get the probabilities

                ## Getting the class from the prediction
                idx = np.argmax(probs, axis=1)  # find the column/index of the high prob
                labels = np.zeros(idx.shape, dtype='uint8')  # Initial array to put predictions in
                for k, v in class_map_dict.items():
                    labels[idx == k] = v  # Map values to the array
            else:
                idxr = bool_arr.reshape(pred_data.shape[0])
                pstack = pred_data[idxr == 0, :]
                probs = rfmod.predict_proba(pstack) * 100  # Get the probabilities
                idx = np.argmax(probs, axis=1)  # find the column/index of the high prob
                preds = np.zeros(idx.shape, dtype='uint8')  # Initial array to put predictions in
                for k, v in class_map_dict.items():
                    preds[idx == k] = v  # Map values to the array
                labels = np.zeros_like(bool_arr).astype('uint8')
                labels[~bool_arr] = preds
                labels[bool_arr] = 0

            preds = labels.reshape(rsizeY, rsizeX, 1)
            classout = np.transpose(preds, (0, 1, 2))[:, :, 0]

            if self.dockwidget.confidenceCheckBox.isChecked():
                conf = np.max(probs, axis=1)  # conf is good to go
                emConfs = np.zeros_like(bool_arr).astype('uint8')
                emConfs[~bool_arr] = conf
                emConfs[bool_arr] = 0
                confs = emConfs.reshape(rsizeY, rsizeX, 1)
                confout = np.transpose(confs, (0, 1, 2))[:, :, 0].astype('uint8')

            if self.dockwidget.classProbsCheckBox.isChecked():
                probholds = []
                numclass = probs.shape[1]
                for x in range(numclass):
                    emProbs = np.zeros_like(bool_arr).astype('uint8')
                    emProbs[~bool_arr] = probs[:, x]
                    emProbs[bool_arr] = 255
                    class_prob_arr2d = emProbs.reshape(rsizeY, rsizeX)
                    probholds.append(class_prob_arr2d)
                probstack = np.stack(probholds)

        else:
            layerName = 'Window_Extent_' + 'RF'

            bb = self.canvas.extent()
            bb.asWktCoordinates()
            bbc = [bb.xMinimum(), bb.yMinimum(), bb.xMaximum(), bb.yMaximum()]
            offsets = boundingBoxToOffsets(bbc, geot)
            new_geot = geotFromOffsets(offsets[0], offsets[2], geot)
            geot = new_geot

            sizeX = int(((bbc[2] - bbc[0]) / cellres) + 1)
            sizeY = int(((bbc[3] - bbc[1]) / cellres) + 1)

            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                dat = extractBandsInBounds(bandList, r_ds, offsets[2], offsets[0], sizeX, sizeY)
            else:
                dat = r_ds.ReadAsArray(offsets[2], offsets[0], sizeX, sizeY)

            data_array = np.transpose(dat, (1, 2, 0))  # convert from bands, rows, columns to rows, cols, bands
            twoDshape = (data_array.shape[0] * data_array.shape[1], data_array.shape[2])
            pred_data = data_array.reshape(twoDshape)

            probs = rfmod.predict_proba(pred_data) * 100  # Get the probabilites

            ## Getting the class from the prediction
            idx = np.argmax(probs, axis=1)  # find the column/index of the high prob
            labels = np.zeros(idx.shape, dtype='uint8')  # Initial array to put predictions in
            for k, v in class_map_dict.items():
                labels[idx == k] = v  # Map values to the array

            preds = labels.reshape(sizeY, sizeX, 1)
            classout = np.transpose(preds, (0, 1, 2))[:, :, 0].astype('uint8')


            if self.dockwidget.confidenceCheckBox.isChecked():
                conf = np.max(probs, axis=1)  # conf is good to go
                confs = conf.reshape(sizeY, sizeX, 1)
                confout = np.transpose(confs, (0, 1, 2))[:, :, 0].astype('uint8')

            if self.dockwidget.classProbsCheckBox.isChecked():
                probholds = []
                numclass = probs.shape[1]
                for x in range(numclass):
                    class_prob_arr1d = probs[:, x]
                    class_prob_arr2d = class_prob_arr1d.reshape(sizeY, sizeX)
                    probholds.append(class_prob_arr2d)

                probstack = np.stack(probholds)


        savedLayer = gdalSave('RFpredict_', classout, gdal.GDT_Byte, geot, r_proj, 0)
        addLayerSymbolMutliClassGroup(savedLayer, layerName, RFgroup, np.unique(classout).tolist(), "Classes")

        if self.dockwidget.confidenceCheckBox.isChecked():
            confLayer = gdalSave("RFconf_", confout, gdal.GDT_Byte, geot, r_proj, 0)
            addRFconfLayer(confLayer, "RF_Conf", RFgroup)

        if self.dockwidget.classProbsCheckBox.isChecked():
            # Right here to update the band Descriptions
            classProbLayer = gdalSave("RFconf_", probstack, gdal.GDT_Byte, geot, r_proj, class_labels, 0)
            addRFconfLayer(classProbLayer, "RF_Prob_", RFgroup)

        predfinished = 'Predictions Mapped'
        print(predfinished)
        self.dockwidget.PrintBox.setText(predfinished)

    def applyRFpreds_PixelFolded(self):
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()

        root = QgsProject.instance().layerTreeRoot()
        if root.findGroup('RF_predicts') == None:
            RFgroup = root.insertGroup(0, 'RF_predicts')
        else:
            RFgroup = root.findGroup('RF_predicts')

        r_ds = gdal.Open(selectedRas.source())
        geot = r_ds.GetGeoTransform()
        r_proj = r_ds.GetProjection()
        nodata = r_ds.GetRasterBand(1).GetNoDataValue()
        cellres = geot[1]
        rsizeX, rsizeY = r_ds.RasterXSize, r_ds.RasterYSize

        rfmod_list = globalVariables['pixel_rfmodel_list']

        class_labels = list(rfmod_list[0].classes_)
        class_idxs = list(range(len(class_labels)))
        class_map_dict = dict(zip(class_idxs, class_labels))

        predstarting = 'Making Predictions'
        print(predstarting)
        self.dockwidget.PrintBox.setText(predstarting)

        if self.dockwidget.ClusterWholeExtentBox.isChecked():
            print("Trying Full")
            layerName = 'Full_Extent_' + 'RF'

            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                dat = extractBands(bandList, r_ds)
            else:
                dat = r_ds.ReadAsArray()

            pred_list = []
            conf_list = []
            prob_list = []

            for rfmod in rfmod_list:

                data_array = np.transpose(dat, (1, 2, 0))  # convert from bands, rows, columns to rows, cols, bands
                twoDshape = (data_array.shape[0] * data_array.shape[1], data_array.shape[2])
                pred_data = data_array.reshape(twoDshape)
                bool_arr = np.all(pred_data == nodata, axis=1)
                if np.count_nonzero(bool_arr == 1) < 1:
                    print('not over no data values')
                    probs = rfmod.predict_proba(pred_data) * 100  # Get the probabilities

                    ## Getting the class from the prediction
                    idx = np.argmax(probs, axis=1)  # find the column/index of the high prob
                    labels = np.zeros(idx.shape, dtype='uint8')  # Initial array to put predictions in
                    for k, v in class_map_dict.items():
                        labels[idx == k] = v  # Map values to the array
                else:
                    idxr = bool_arr.reshape(pred_data.shape[0])
                    pstack = pred_data[idxr == 0, :]
                    probs = rfmod.predict_proba(pstack) * 100  # Get the probabilities
                    idx = np.argmax(probs, axis=1)  # find the column/index of the high prob
                    preds = np.zeros(idx.shape, dtype='uint8')  # Initial array to put predictions in
                    for k, v in class_map_dict.items():
                        preds[idx == k] = v  # Map values to the array
                    labels = np.zeros_like(bool_arr).astype('uint8')
                    labels[~bool_arr] = preds
                    labels[bool_arr] = 0



                preds = labels.reshape(rsizeY, rsizeX, 1)
                classout = np.transpose(preds, (0, 1, 2))[:, :, 0].astype('uint8')
                pred_list.append(classout)

                if self.dockwidget.confidenceCheckBox.isChecked():
                    conf = np.max(probs, axis=1)  # conf is good to go
                    emConfs = np.zeros_like(bool_arr).astype('uint8')
                    emConfs[~bool_arr] = conf
                    emConfs[bool_arr] = 0
                    confs = emConfs.reshape(rsizeY, rsizeX, 1)
                    confout = np.transpose(confs, (0, 1, 2))[:, :, 0].astype('uint8')
                    conf_list.append(confout)

                if self.dockwidget.classProbsCheckBox.isChecked():
                    probholds = []
                    numclass = probs.shape[1]
                    for x in range(numclass):
                        emProbs = np.zeros_like(bool_arr).astype('uint8')
                        emProbs[~bool_arr] = probs[:, x]
                        emProbs[bool_arr] = 255

                        # class_prob_arr1d = probs[:, x]
                        class_prob_arr2d = emProbs.reshape(rsizeY, rsizeX)
                        probholds.append(class_prob_arr2d)

                    probstack = np.stack(probholds)
                    prob_list.append(probstack)

        else:
            layerName = 'Window_Extent_' + 'RF'

            bb = self.canvas.extent()
            bb.asWktCoordinates()
            bbc = [bb.xMinimum(), bb.yMinimum(), bb.xMaximum(), bb.yMaximum()]
            offsets = boundingBoxToOffsets(bbc, geot)
            new_geot = geotFromOffsets(offsets[0], offsets[2], geot)
            geot = new_geot

            sizeX = int(((bbc[2] - bbc[0]) / cellres) + 1)
            sizeY = int(((bbc[3] - bbc[1]) / cellres) + 1)

            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                dat = extractBandsInBounds(bandList, r_ds, offsets[2], offsets[0], sizeX, sizeY)
            else:
                dat = r_ds.ReadAsArray(offsets[2], offsets[0], sizeX, sizeY)

            pred_list = []
            conf_list = []
            prob_list = []

            for rfmod in rfmod_list:

                data_array = np.transpose(dat, (1, 2, 0))  # convert from bands, rows, columns to rows, cols, bands
                twoDshape = (data_array.shape[0] * data_array.shape[1], data_array.shape[2])
                pred_data = data_array.reshape(twoDshape)

                probs = rfmod.predict_proba(pred_data) * 100  # Get the probabilities

                ## Getting the class from the prediction
                idx = np.argmax(probs, axis=1)  # find the column/index of the high prob
                labels = np.zeros(idx.shape, dtype='uint8')  # Initial array to put predictions in
                for k, v in class_map_dict.items():
                    labels[idx == k] = v  # Map values to the array

                preds = labels.reshape(sizeY, sizeX, 1)
                classout = np.transpose(preds, (0, 1, 2))[:, :, 0].astype('uint8')
                pred_list.append(classout)

                if self.dockwidget.confidenceCheckBox.isChecked():
                    conf = np.max(probs, axis=1)  # conf is good to go
                    confs = conf.reshape(sizeY, sizeX, 1)
                    confout = np.transpose(confs, (0, 1, 2))[:, :, 0].astype('uint8')
                    conf_list.append(confout)

                if self.dockwidget.classProbsCheckBox.isChecked():
                    probholds = []
                    numclass = probs.shape[1]
                    for x in range(numclass):
                        class_prob_arr1d = probs[:, x]
                        class_prob_arr2d = class_prob_arr1d.reshape(sizeY, sizeX)
                        probholds.append(class_prob_arr2d)

                    probstack = np.stack(probholds)
                    prob_list.append(probstack)

        mode_arr = calc_array_mode(pred_list)
        mode_layer = gdalSave('RFpredict_', mode_arr, gdal.GDT_Byte, geot, r_proj, 0)
        addLayerSymbolMutliClassGroup(mode_layer, 'Prediction_Mode', RFgroup, np.unique(classout).tolist(), "Classes")

        if self.dockwidget.confidenceCheckBox.isChecked():
            ave_conf_arr = np.mean(conf_list, axis=0).astype(np.int8)
            confLayer = gdalSave("RFconf_", ave_conf_arr, gdal.GDT_Byte, geot, r_proj, 0)
            addRFconfLayer(confLayer, "Ave_RF_Conf", RFgroup)

        if self.dockwidget.classProbsCheckBox.isChecked():
            # Right here to update the band Descriptions
            ave_prob_arr = np.mean(prob_list, axis=0).astype(np.int8)
            classProbLayer = gdalSave("RFconf_", ave_prob_arr, gdal.GDT_Byte, geot, r_proj, class_labels, 0)
            addRFconfLayer(classProbLayer, "Ave_RF_Prob_", RFgroup)

        predfinished = 'Predictions Mapped'
        print(predfinished)
        self.dockwidget.PrintBox.setText(predfinished)

    def selectRFtrainPoly(self):
        num_iters = self.dockwidget.numRFitersBox.value()
        if num_iters > 1:
            print(f"doing {num_iters} iterations")
            self.buildRFmodelPolyMultiIter()
        else:
            print("Doing one off validation")
            self.buildRFmodelPolysOneOff()

    def selectRFapplyPoly(self):
        num_iters = self.dockwidget.numRFitersBox.value()
        if num_iters > 1:
            self.applyRFpredsPolyMultiple()
        else:
            self.applyRFpredsPolySingle()

    def buildRFmodelPolyMultiIter(self):
        selectedLayer = self.dockwidget.comboBox_vector.currentLayer()
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        bands = rasterBandDescAslist(selectedRas.source())
        num_iters = self.dockwidget.numRFitersBox.value()
        val_pct = self.dockwidget.TestHoldPct_spinBox.value()
        train_pct = 100 - val_pct
        samplingRate = self.dockwidget.samplingRatespinBox.value()
        maxPixPoly = self.dockwidget.max_pix_poly_spinBox.value()
        maxClassPix = self.dockwidget.max_sample_spinBox.value()
        njobs = self.dockwidget.njob_box.value()
        params = {'FIELD': 'type_id', 'INPUT': selectedLayer, 'METHOD': 1, 'NUMBER': train_pct}

        band_imp_list = []
        test_label_list = []
        y_pred_list = []
        rfmod_list = []
        for iter_ in range(1, num_iters+1):
            print("---------------------------------------------------")
            print(f"Iteration # {iter_}")
            # Take random selection within each class type
            processing.run("qgis:randomselectionwithinsubsets", params)

            # Gather Training data from Selected % of Polygons per class
            train_dat = getTrainingDataFromFeatures(selectedRas, selectedLayer, withSelected=True, samplingRate=samplingRate, maxPerPoly=maxPixPoly)

            if self.dockwidget.UseBandSelectionBox.isChecked():
                train_dat, bands = dropSelectedBandsforSupClass(train_dat, bandSelToList(self.dockwidget.stats_table), bands)

            if self.dockwidget.lowestSample_CheckBox.isChecked():
                train_dat = balancedSamples(train_dat, take_min=True, n=maxClassPix)
            else:
                train_dat = balancedSamples(train_dat, take_min=False, n=maxClassPix)

            train_labels = train_dat[:, 0]
            train_features = train_dat[:, 1:train_dat.shape[0]]

            if self.dockwidget.custom_RF_checkBox.isChecked():
                print("using custom parameters")
                n_estimates = self.dockwidget.n_estimators_spinBox.value()
                maxfeatures = self.dockwidget.max_features_comboBox.currentText()
                max_dpth = self.dockwidget.max_depth_spinBox.value()
                min_samp_split = self.dockwidget.min_sample_spinBox_2.value()
                rfmod = RandomForestClassifier(n_estimators=n_estimates, max_depth=max_dpth, max_features=maxfeatures,
                                               min_samples_split=min_samp_split, n_jobs=njobs)
            else:
                rfmod = RandomForestClassifier(n_jobs=njobs)

            rfmod.fit(train_features, train_labels)
            rfmod_list.append(rfmod)

            band_imp_list.append(rfmod.feature_importances_)

            # Gather Test data from inverted selection of features for validation
            selectedLayer.invertSelection()
            test_dat = getTrainingDataFromFeatures(selectedRas, selectedLayer, withSelected=True, samplingRate=samplingRate, maxPerPoly=maxPixPoly)
            if self.dockwidget.UseBandSelectionBox.isChecked():
                test_dat, dontUsebands = dropSelectedBandsforSupClass(test_dat, bandSelToList(self.dockwidget.stats_table), bands)
            test_labels = test_dat[:, 0]
            test_features = test_dat[:, 1:test_dat.shape[0]]
            y_pred = rfmod.predict(test_features)
            test_label_list.append(test_labels)
            y_pred_list.append(y_pred)



            if self.dockwidget.errors_CheckBox.isChecked():
                print(' -------------- Classification Report ------------------')
                print('                                            ')
                print(classification_report(test_labels, y_pred, labels=list(np.unique((train_labels).astype('uint8')))))
                print('                                            ')

            if self.dockwidget.Conf_Checkbox.isChecked():
                print(' ---------- Confusion Matrix -------------')
                print('                                            ')
                cm = confusion_matrix(test_labels, y_pred)
                cmdf = pd.DataFrame(cm, columns=list(np.unique((train_labels).astype('uint8'))))
                cmdf.index = list(np.unique((train_labels).astype('uint8')))
                print(cmdf)
                print('                                                            ')
                # error_mat_list.append(cm)

            if self.dockwidget.BandImportance_CheckBox.isChecked():
                print(' --------- Band Importance -----------------')
                print('                                            ')
                importances = list(rfmod.feature_importances_)  # List of tuples with variable and importance
                feature_importances = [(feature, round(importance, 2)) for feature, importance in
                                       zip(bands, importances)]  # Sort the feature importances by most important first
                feature_importances = sorted(feature_importances, key=lambda x: x[1],
                                             reverse=True)  # Print out the feature and importances
                for fi in feature_importances:
                    print('{:15} Importance: {}'.format(*fi))


            print(f"############# END SHUFFLE {iter_}  ################################")


        folded_y_preds = np.concatenate(y_pred_list)
        folded_test_labels = np.concatenate(test_label_list)

        cm = (confusion_matrix(folded_test_labels, folded_y_preds)/num_iters).astype('uint16')
        globalVariables['valset'] = {'actual': folded_test_labels, 'predicted': folded_y_preds}
        cmdf = pd.DataFrame(cm, columns=list(np.unique((train_labels).astype('uint8'))))
        cmdf.index = list(np.unique((train_labels).astype('uint8')))
        print("########################################################################")
        print(f"############### AVERAGED ERROR MATRIX FROM {num_iters} RANDOM POLYGON SHUFFLES ################")
        print("########################################################################")
        print(cmdf)
        print('___________________________________________________')

        print(f"############### AVERAGED CLASSIFICATION REPORT FROM {num_iters} RANDOM POLYGON SHUFFLES ################")
        print(classification_report(folded_test_labels, folded_y_preds, labels=list(np.unique((train_labels).astype('uint8')))))
        print('___________________________________________________')
        print(f"############### TOP BAND IMPORTANCES FROM AVERAGED  {num_iters} RANDOM POLYGON SHUFFLES ################")
        imps = np.vstack(band_imp_list).T
        ave_imp = np.mean(imps, axis=1)

        feature_importances = [(feature, round(importance, 2)) for feature, importance in
                               zip(bands, ave_imp)]  # Sort the feature importances by most important first
        feature_importances = sorted(feature_importances, key=lambda x: x[1],
                                     reverse=True)  # Print out the feature and importances

        for fi in feature_importances:
            print('{:15} Importance: {}'.format(*fi))

        globalVariables['poly_rfmodel_list'] = rfmod_list

    def buildRFmodelPolysOneOff(self):
        selectedLayer = self.dockwidget.comboBox_vector.currentLayer()
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()
        samplingRate = self.dockwidget.samplingRatespinBox.value()
        maxPixPoly = self.dockwidget.max_pix_poly_spinBox.value()
        maxClassPix = self.dockwidget.max_sample_spinBox.value()
        bands = rasterBandDescAslist(selectedRas.source())
        val_pct = self.dockwidget.TestHoldPct_spinBox.value()
        train_pct = 100 - val_pct
        njobs = self.dockwidget.njob_box.value()
        params = {'FIELD': 'type_id', 'INPUT': selectedLayer, 'METHOD': 1, 'NUMBER': train_pct}
        processing.run("qgis:randomselectionwithinsubsets", params)

        trainingstarting = f'Training Model with now selected polygons. One off test'
        print(trainingstarting)
        self.dockwidget.PrintBox.setText(trainingstarting)

        # Gather Training data from Selected % of Polygons per class
        train_dat = getTrainingDataFromFeatures(selectedRas, selectedLayer, withSelected=True, samplingRate=samplingRate, maxPerPoly=maxPixPoly)

        if self.dockwidget.UseBandSelectionBox.isChecked():
            train_dat, bands = dropSelectedBandsforSupClass(train_dat, bandSelToList(self.dockwidget.stats_table), bands)

        if self.dockwidget.lowestSample_CheckBox.isChecked():
            train_dat = balancedSamples(train_dat, take_min=True, n=maxClassPix)
        else:
            train_dat = balancedSamples(train_dat, take_min=False, n=maxClassPix)
        train_labels = train_dat[:, 0]
        train_features = train_dat[:, 1:train_dat.shape[0]]
        if self.dockwidget.custom_RF_checkBox.isChecked():
            print("using custom parameters")
            n_estimates = self.dockwidget.n_estimators_spinBox.value()
            maxfeatures = self.dockwidget.max_features_comboBox.currentText()
            max_dpth = self.dockwidget.max_depth_spinBox.value()
            min_samp_split = self.dockwidget.min_sample_spinBox_2.value()
            rfmod = RandomForestClassifier(n_estimators=n_estimates, max_depth=max_dpth, max_features=maxfeatures,
                                           min_samples_split=min_samp_split, n_jobs=njobs)
        else:
            rfmod = RandomForestClassifier(n_jobs=njobs)

        rfmod.fit(train_features, train_labels)

        # globalVariables['rfmodel'] = rfmod
        globalVariables['poly_rfmodel'] = rfmod

        trainingdone = 'Model Training Finished'
        print(trainingdone)
        self.dockwidget.PrintBox.setText(trainingdone)

        if self.dockwidget.errors_CheckBox.isChecked() or self.dockwidget.Conf_Checkbox.isChecked():
            validatingstring = 'Validating pixels in the now selected polygons'
            print(validatingstring)
            self.dockwidget.PrintBox.setText(validatingstring)
            # Gather Test data from inverted selection of features
            selectedLayer.invertSelection()
            sleep(1)
            test_dat = getTrainingDataFromFeatures(selectedRas, selectedLayer, withSelected=True, samplingRate=samplingRate, maxPerPoly=maxPixPoly)
            if self.dockwidget.UseBandSelectionBox.isChecked():
                test_dat, dontUsebands = dropSelectedBandsforSupClass(test_dat, bandSelToList(self.dockwidget.stats_table),
                                                                bands)
            test_labels = test_dat[:, 0]
            test_features = test_dat[:, 1:test_dat.shape[0]]
            y_pred = rfmod.predict(test_features)

        if self.dockwidget.errors_CheckBox.isChecked():
            print(' -------------- Classification Report ------------------')
            print('                                            ')
            print(classification_report(test_labels, y_pred, labels=list(np.unique((train_labels).astype('uint8')))))
            print('                                            ')

        if self.dockwidget.Conf_Checkbox.isChecked():
            print(' ---------- Confusion Matrix -------------')
            print('                                            ')
            cm = confusion_matrix(test_labels, y_pred)
            globalVariables['valset'] = {'actual': test_labels, 'predicted': y_pred}
            cmdf = pd.DataFrame(cm, columns=list(np.unique((train_labels).astype('uint8'))))
            cmdf.index = list(np.unique((train_labels).astype('uint8')))
            print(cmdf)

            print('                                                            ')

        if self.dockwidget.BandImportance_CheckBox.isChecked():
            print(' --------- Band Importance -----------------')
            print('                                            ')
            importances = list(rfmod.feature_importances_)  # List of tuples with variable and importance
            feature_importances = [(feature, round(importance, 2)) for feature, importance in
                                   zip(bands, importances)]  # Sort the feature importances by most important first
            feature_importances = sorted(feature_importances, key=lambda x: x[1],
                                         reverse=True)  # Print out the feature and importances
            for fi in feature_importances:
                print('{:15} Importance: {}'.format(*fi))

    def applyRFpredsPolyMultiple(self):
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()

        root = QgsProject.instance().layerTreeRoot()
        if root.findGroup('RF_predicts') == None:
            RFgroup = root.insertGroup(0, 'RF_predicts')
        else:
            RFgroup = root.findGroup('RF_predicts')

        r_ds = gdal.Open(selectedRas.source())
        geot = r_ds.GetGeoTransform()
        r_proj = r_ds.GetProjection()
        nodata = r_ds.GetRasterBand(1).GetNoDataValue()
        cellres = geot[1]
        rsizeX, rsizeY = r_ds.RasterXSize, r_ds.RasterYSize

        rfmod_list = globalVariables['poly_rfmodel_list']

        class_labels = list(rfmod_list[0].classes_)
        class_idxs = list(range(len(class_labels)))
        class_map_dict = dict(zip(class_idxs, class_labels))

        predstarting = 'Making Predictions'
        print(predstarting)
        self.dockwidget.PrintBox.setText(predstarting)

        if self.dockwidget.ClusterWholeExtentBox.isChecked():
            print("Trying Full")
            layerName = 'Full_Extent_' + 'RF'

            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                dat = extractBands(bandList, r_ds)
            else:
                dat = r_ds.ReadAsArray()

            pred_list = []
            conf_list = []
            prob_list = []

            for rfmod in rfmod_list:

                data_array = np.transpose(dat, (1, 2, 0))  # convert from bands, rows, columns to rows, cols, bands
                twoDshape = (data_array.shape[0] * data_array.shape[1], data_array.shape[2])
                pred_data = data_array.reshape(twoDshape)
                bool_arr = np.all(pred_data == nodata, axis=1)
                if np.count_nonzero(bool_arr == 1) < 1:
                    print('not over no data values')
                    probs = rfmod.predict_proba(pred_data) * 100  # Get the probabilities

                    ## Getting the class from the prediction
                    idx = np.argmax(probs, axis=1)  # find the column/index of the high prob
                    labels = np.zeros(idx.shape, dtype='uint8')  # Initial array to put predictions in
                    for k, v in class_map_dict.items():
                        labels[idx == k] = v  # Map values to the array
                else:
                    idxr = bool_arr.reshape(pred_data.shape[0])
                    pstack = pred_data[idxr == 0, :]
                    probs = rfmod.predict_proba(pstack) * 100  # Get the probabilities
                    idx = np.argmax(probs, axis=1)  # find the column/index of the high prob
                    preds = np.zeros(idx.shape, dtype='uint8')  # Initial array to put predictions in
                    for k, v in class_map_dict.items():
                        preds[idx == k] = v  # Map values to the array
                    labels = np.zeros_like(bool_arr).astype('uint8')
                    labels[~bool_arr] = preds
                    labels[bool_arr] = 0

                preds = labels.reshape(rsizeY, rsizeX, 1)
                classout = np.transpose(preds, (0, 1, 2))[:, :, 0].astype('uint8')
                pred_list.append(classout)

                if self.dockwidget.confidenceCheckBox.isChecked():
                    conf = np.max(probs, axis=1)  # conf is good to go
                    emConfs = np.zeros_like(bool_arr).astype('uint8')
                    emConfs[~bool_arr] = conf
                    emConfs[bool_arr] = 0
                    confs = emConfs.reshape(rsizeY, rsizeX, 1)
                    confout = np.transpose(confs, (0, 1, 2))[:, :, 0].astype('uint8')
                    conf_list.append(confout)

                if self.dockwidget.classProbsCheckBox.isChecked():
                    probholds = []
                    numclass = probs.shape[1]
                    for x in range(numclass):
                        emProbs = np.zeros_like(bool_arr).astype('uint8')
                        emProbs[~bool_arr] = probs[:, x]
                        emProbs[bool_arr] = 255

                        # class_prob_arr1d = probs[:, x]
                        class_prob_arr2d = emProbs.reshape(rsizeY, rsizeX)
                        probholds.append(class_prob_arr2d)

                    probstack = np.stack(probholds)
                    prob_list.append(probstack)

        else:
            layerName = 'Window_Extent_' + 'RF'

            bb = self.canvas.extent()
            bb.asWktCoordinates()
            bbc = [bb.xMinimum(), bb.yMinimum(), bb.xMaximum(), bb.yMaximum()]
            offsets = boundingBoxToOffsets(bbc, geot)
            new_geot = geotFromOffsets(offsets[0], offsets[2], geot)
            geot = new_geot

            sizeX = int(((bbc[2] - bbc[0]) / cellres) + 1)
            sizeY = int(((bbc[3] - bbc[1]) / cellres) + 1)

            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                dat = extractBandsInBounds(bandList, r_ds, offsets[2], offsets[0], sizeX, sizeY)
            else:
                dat = r_ds.ReadAsArray(offsets[2], offsets[0], sizeX, sizeY)

            pred_list = []
            conf_list = []
            prob_list = []

            for rfmod in rfmod_list:

                data_array = np.transpose(dat, (1, 2, 0))  # convert from bands, rows, columns to rows, cols, bands
                twoDshape = (data_array.shape[0] * data_array.shape[1], data_array.shape[2])
                pred_data = data_array.reshape(twoDshape)

                probs = rfmod.predict_proba(pred_data) * 100  # Get the probabilities

                ## Getting the class from the prediction
                idx = np.argmax(probs, axis=1)  # find the column/index of the high prob
                labels = np.zeros(idx.shape, dtype='uint8')  # Initial array to put predictions in
                for k, v in class_map_dict.items():
                    labels[idx == k] = v  # Map values to the array

                preds = labels.reshape(sizeY, sizeX, 1)
                classout = np.transpose(preds, (0, 1, 2))[:, :, 0].astype('uint8')
                pred_list.append(classout)


                if self.dockwidget.confidenceCheckBox.isChecked():
                    conf = np.max(probs, axis=1)  # conf is good to go
                    confs = conf.reshape(sizeY, sizeX, 1)
                    confout = np.transpose(confs, (0, 1, 2))[:, :, 0].astype('uint8')
                    conf_list.append(confout)

                if self.dockwidget.classProbsCheckBox.isChecked():
                    probholds = []
                    numclass = probs.shape[1]
                    for x in range(numclass):
                        class_prob_arr1d = probs[:, x]
                        class_prob_arr2d = class_prob_arr1d.reshape(sizeY, sizeX)
                        probholds.append(class_prob_arr2d)

                    probstack = np.stack(probholds)
                    prob_list.append(probstack)

        mode_arr = calc_array_mode(pred_list)
        mode_layer = gdalSave('RFpredict_', mode_arr, gdal.GDT_Byte, geot, r_proj, 0)
        addLayerSymbolMutliClassGroup(mode_layer, 'Prediction_Mode', RFgroup, np.unique(classout).tolist(), "Classes")

        if self.dockwidget.confidenceCheckBox.isChecked():
            ave_conf_arr = np.mean(conf_list, axis=0).astype(np.int8)
            confLayer = gdalSave("RFconf_", ave_conf_arr, gdal.GDT_Byte, geot, r_proj, 0)
            addRFconfLayer(confLayer, "Ave_RF_Conf", RFgroup)

        if self.dockwidget.classProbsCheckBox.isChecked():
            # Right here to update the band Descriptions
            ave_prob_arr = np.mean(prob_list, axis=0).astype(np.int8)
            classProbLayer = gdalSave("RFconf_", ave_prob_arr, gdal.GDT_Byte, geot, r_proj, class_labels, 0)
            addRFconfLayer(classProbLayer, "Ave_RF_Prob_", RFgroup)

        predfinished = 'Predictions Mapped'
        print(predfinished)
        self.dockwidget.PrintBox.setText(predfinished)

    def applyRFpredsPolySingle(self):
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()

        root = QgsProject.instance().layerTreeRoot()
        if root.findGroup('RF_predicts') == None:
            RFgroup = root.insertGroup(0, 'RF_predicts')
        else:
            RFgroup = root.findGroup('RF_predicts')

        r_ds = gdal.Open(selectedRas.source())
        geot = r_ds.GetGeoTransform()
        r_proj = r_ds.GetProjection()
        nodata = r_ds.GetRasterBand(1).GetNoDataValue()
        cellres = geot[1]
        rsizeX, rsizeY = r_ds.RasterXSize, r_ds.RasterYSize

        rfmod = globalVariables['poly_rfmodel']

        class_labels = list(rfmod.classes_)
        class_idxs = list(range(len(class_labels)))
        class_map_dict = dict(zip(class_idxs, class_labels))

        predstarting = 'Making Predictions'
        print(predstarting)
        self.dockwidget.PrintBox.setText(predstarting)

        if self.dockwidget.ClusterWholeExtentBox.isChecked():
            layerName = 'Full_Extent_' + 'RF'

            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                dat = extractBands(bandList, r_ds)
            else:
                dat = r_ds.ReadAsArray()

            data_array = np.transpose(dat, (1, 2, 0))  # convert from bands, rows, columns to rows, cols, bands
            twoDshape = (data_array.shape[0] * data_array.shape[1], data_array.shape[2])
            pred_data = data_array.reshape(twoDshape)
            bool_arr = np.all(pred_data == nodata, axis=1)
            if np.count_nonzero(bool_arr == 1) < 1:
                print('not over no data values')
                probs = rfmod.predict_proba(pred_data) * 100  # Get the probabilities

                ## Getting the class from the prediction
                idx = np.argmax(probs, axis=1)  # find the column/index of the high prob
                labels = np.zeros(idx.shape, dtype='uint8')  # Initial array to put predictions in
                for k, v in class_map_dict.items():
                    labels[idx == k] = v  # Map values to the array
            else:
                idxr = bool_arr.reshape(pred_data.shape[0])
                pstack = pred_data[idxr == 0, :]
                probs = rfmod.predict_proba(pstack) * 100  # Get the probabilities
                idx = np.argmax(probs, axis=1)  # find the column/index of the high prob
                preds = np.zeros(idx.shape, dtype='uint8')  # Initial array to put predictions in
                for k, v in class_map_dict.items():
                    preds[idx == k] = v  # Map values to the array
                labels = np.zeros_like(bool_arr).astype('uint8')
                labels[~bool_arr] = preds
                labels[bool_arr] = 0

            preds = labels.reshape(rsizeY, rsizeX, 1)
            classout = np.transpose(preds, (0, 1, 2))[:, :, 0]

            if self.dockwidget.confidenceCheckBox.isChecked():
                conf = np.max(probs, axis=1)  # conf is good to go
                emConfs = np.zeros_like(bool_arr).astype('uint8')
                emConfs[~bool_arr] = conf
                emConfs[bool_arr] = 0
                confs = emConfs.reshape(rsizeY, rsizeX, 1)
                confout = np.transpose(confs, (0, 1, 2))[:, :, 0].astype('uint8')

            if self.dockwidget.classProbsCheckBox.isChecked():
                probholds = []
                numclass = probs.shape[1]
                for x in range(numclass):
                    emProbs = np.zeros_like(bool_arr).astype('uint8')
                    emProbs[~bool_arr] = probs[:, x]
                    emProbs[bool_arr] = 255
                    class_prob_arr2d = emProbs.reshape(rsizeY, rsizeX)
                    probholds.append(class_prob_arr2d)
                probstack = np.stack(probholds)


        else:
            layerName = 'Window_Extent_' + 'RF'

            bb = self.canvas.extent()
            bb.asWktCoordinates()
            bbc = [bb.xMinimum(), bb.yMinimum(), bb.xMaximum(), bb.yMaximum()]
            offsets = boundingBoxToOffsets(bbc, geot)
            new_geot = geotFromOffsets(offsets[0], offsets[2], geot)
            geot = new_geot

            sizeX = int(((bbc[2] - bbc[0]) / cellres) + 1)
            sizeY = int(((bbc[3] - bbc[1]) / cellres) + 1)

            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                dat = extractBandsInBounds(bandList, r_ds, offsets[2], offsets[0], sizeX, sizeY)
            else:
                dat = r_ds.ReadAsArray(offsets[2], offsets[0], sizeX, sizeY)

            data_array = np.transpose(dat, (1, 2, 0))  # convert from bands, rows, columns to rows, cols, bands
            twoDshape = (data_array.shape[0] * data_array.shape[1], data_array.shape[2])
            pred_data = data_array.reshape(twoDshape)

            probs = rfmod.predict_proba(pred_data) * 100  # Get the probabilites

            ## Getting the class from the prediction
            idx = np.argmax(probs, axis=1)  # find the column/index of the high prob
            labels = np.zeros(idx.shape, dtype='uint8')  # Initial array to put predictions in
            for k, v in class_map_dict.items():
                labels[idx == k] = v  # Map values to the array

            preds = labels.reshape(sizeY, sizeX, 1)
            classout = np.transpose(preds, (0, 1, 2))[:, :, 0].astype('uint8')


            if self.dockwidget.confidenceCheckBox.isChecked():
                conf = np.max(probs, axis=1)  # conf is good to go
                confs = conf.reshape(sizeY, sizeX, 1)
                confout = np.transpose(confs, (0, 1, 2))[:, :, 0].astype('uint8')

            if self.dockwidget.classProbsCheckBox.isChecked():
                probholds = []
                numclass = probs.shape[1]
                for x in range(numclass):
                    class_prob_arr1d = probs[:, x]
                    class_prob_arr2d = class_prob_arr1d.reshape(sizeY, sizeX)
                    probholds.append(class_prob_arr2d)

                probstack = np.stack(probholds)


        savedLayer = gdalSave('RFpredict_', classout, gdal.GDT_Byte, geot, r_proj, 0)
        addLayerSymbolMutliClassGroup(savedLayer, layerName, RFgroup, np.unique(classout).tolist(), "Classes")

        if self.dockwidget.confidenceCheckBox.isChecked():
            confLayer = gdalSave("RFconf_", confout, gdal.GDT_Byte, geot, r_proj, 0)
            addRFconfLayer(confLayer, "RF_Conf", RFgroup)

        if self.dockwidget.classProbsCheckBox.isChecked():
            # Right here to update the band Descriptions
            classProbLayer = gdalSave("RFconf_", probstack, gdal.GDT_Byte, geot, r_proj, class_labels, 0)
            addRFconfLayer(classProbLayer, "RF_Prob_", RFgroup)

        predfinished = 'Predictions Mapped'
        print(predfinished)
        self.dockwidget.PrintBox.setText(predfinished)

    def export_conf_mat(self):
        filename = QFileDialog.getSaveFileName(self.dockwidget, self.tr("Select output file"), "", self.tr('*.csv'))[0] + '.csv'
        valdict = globalVariables['valset']

        # target_names = 'find way'
        # label_dict = json.loads(self.dockwidget.PrintBox.text())
        target_names = self.dockwidget.PrintBox.text().split(",")


        conf_mat = make_fullConfMat(valdict['actual'], valdict['predicted'], target_names)
        conf_mat.to_csv(filename, index=False)

    def sample_raster_at_points(self):
        # TODO Should be able to do Points or Polygons depending on the geometry type
        data_ras = self.dockwidget.comboBox_raster.currentLayer()
        selectedLayer = self.dockwidget.training_layer_combo_box.currentLayer()
        datastr = selectedLayer.source()

        try:
            # This will be the case for geopackages, but not shapefile or geojson
            fp, layername = datastr.split('|')
            gdf = gpd.read_file(fp, layername=layername.split('=')[1])
        except ValueError:
            fp = datastr
            gdf = gpd.read_file(fp)

        # fp, layername = datastr.split('|')
        # gdf = gpd.read_file(fp, layername=layername.split('=')[1])
        raster = rio.open(data_ras.source())
        raster_crs = raster.crs
        if gdf.crs != raster_crs:
            gdf.to_crs(raster_crs, inplace=True)
        nodata = raster.nodata
        bands = raster.descriptions
        coords = [(x, y) for x, y in zip(gdf.geometry.x, gdf.geometry.y)]  # list of gdf lat/longs
        samples = [x for x in raster.sample(coords, masked=True)]
        s = np.array(samples)
        # Drop rows with nodata value
        dat = s[~(s == nodata).any(1), :]
        # Turn into dataframe for keeping
        df = pd.DataFrame(dat, columns=bands)
        print(df.head())

        statement = f"{dat.shape[0]} sample points collected. \n {s.shape[0] - dat.shape[0]} " \
                   f"dropped from intersection with nodata values."

        self.dockwidget.PrintBox.setText(statement)
        self.iface.messageBar().pushMessage(statement)

        globalVariables['point_samples'] = df

    def trainOneClassSVM(self):
        if 'oneClassSVM' in globalVariables:
            globalVariables['oneClassSVM'] = None

        pointdata = globalVariables['point_samples']
        x_train = pointdata.to_numpy()

        # One class SVM
        # Can add inputs for user defnined parameters later
        kernel = 'rbf'
        nu = 0.5
        gamma = 0.001

        ocsvm = svm.OneClassSVM(nu=nu, kernel=kernel, gamma=gamma)
        ocsvm.fit(x_train)

        # # Isolation Forest
        # ocsvm = IsolationForest()
        # ocsvm.fit(x_train)

        ## Local Outlier Factor
        # ocsvm = LocalOutlierFactor(novelty=True)
        # ocsvm.fit(x_train)

        self.dockwidget.PrintBox.setText('SVM Model Fit')
        globalVariables['oneClassSVM'] = ocsvm

    def mapSVMscores(self):
        selectedRas = self.dockwidget.comboBox_raster.currentLayer()

        root = QgsProject.instance().layerTreeRoot()
        if root.findGroup('One Class SVM') == None:
            SVMgroup = root.insertGroup(0, 'One Class SVM')
        else:
            SVMgroup = root.findGroup('One Class SVM')

        r_ds = gdal.Open(selectedRas.source())
        geot = r_ds.GetGeoTransform()
        r_proj = r_ds.GetProjection()
        nodata = r_ds.GetRasterBand(1).GetNoDataValue()
        cellres = geot[1]
        rsizeX, rsizeY = r_ds.RasterXSize, r_ds.RasterYSize

        ocsvm = globalVariables['oneClassSVM']

        if self.dockwidget.ClusterWholeExtentBox.isChecked():
            layerName = 'Full_Extent_' + 'One Class SVM'

            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                dat = extractBands(bandList, r_ds)
            else:
                dat = r_ds.ReadAsArray()

            data_array = np.transpose(dat, (1, 2, 0))  # convert from bands, rows, columns to rows, cols, bands
            twoDshape = (data_array.shape[0] * data_array.shape[1], data_array.shape[2])
            pred_data = data_array.reshape(twoDshape)
            bool_arr = np.all(pred_data == nodata, axis=1)
            if np.count_nonzero(bool_arr == 1) < 1:
                print('not over no data values')
                scores = ocsvm.score_samples(pred_data)

            else:
                idxr = bool_arr.reshape(pred_data.shape[0])
                pstack = pred_data[idxr == 0, :]
                scrs = ocsvm.score_samples(pstack)

                scores = np.zeros_like(bool_arr, dtype='float32')
                scores[~bool_arr] = scrs
                scores[bool_arr] = 0

            preds = scores.reshape(rsizeY, rsizeX, 1)
            classout = np.transpose(preds, (0, 1, 2))[:, :, 0]


        else:
            layerName = 'Window_Extent_' + 'One Class SVM'

            bb = self.canvas.extent()
            bb.asWktCoordinates()
            bbc = [bb.xMinimum(), bb.yMinimum(), bb.xMaximum(), bb.yMaximum()]
            offsets = boundingBoxToOffsets(bbc, geot)
            new_geot = geotFromOffsets(offsets[0], offsets[2], geot)
            geot = new_geot

            sizeX = int(((bbc[2] - bbc[0]) / cellres) + 1)
            sizeY = int(((bbc[3] - bbc[1]) / cellres) + 1)

            if self.dockwidget.UseBandSelectionBox.isChecked():
                bandList = bandSelToList(self.dockwidget.stats_table)
                dat = extractBandsInBounds(bandList, r_ds, offsets[2], offsets[0], sizeX, sizeY)
            else:
                dat = r_ds.ReadAsArray(offsets[2], offsets[0], sizeX, sizeY)

            data_array = np.transpose(dat, (1, 2, 0))  # convert from bands, rows, columns to rows, cols, bands
            twoDshape = (data_array.shape[0] * data_array.shape[1], data_array.shape[2])
            pred_data = data_array.reshape(twoDshape)

            scores = ocsvm.score_samples(pred_data)

            preds = scores.reshape(sizeY, sizeX, 1)
            classout = np.transpose(preds, (0, 1, 2))[:, :, 0]


        savedLayer = gdalSave('SVM_Scores', classout.astype('float32'), gdal.GDT_Float32, geot, r_proj, float(np.finfo('float32').min))
        addRFconfLayer(savedLayer, "SVM_Score", SVMgroup)

    def print_estimated_size(self):
        selectedLayer = self.dockwidget.template_input.currentLayer()
        # TODO Deterimine if it's a raster or vector. Repeat for make template as well
        # TODO have the abiity to get the draw rectangle function
        datastr = selectedLayer.source()
        pixel_size = self.dockwidget.pixel_size_input.value()
        buffer_distance = self.dockwidget.buffer_dist_spinBox.value()

        try:
            # This will be the case for geopackages, but not shapefile or geojson
            fp, layername = datastr.split('|')
        except ValueError:
            fp = datastr

        # There may need to be some crs projection stuff here, but wouldn't change the memory much I imagine
        box_crs = self.dockwidget.mQgsProjectionSelectionWidget.crs()
        input_crsWkt = box_crs.toWkt()
        new_crs = rio.crs.CRS.from_wkt(input_crsWkt)

        bounds = gpd.read_file(fp).to_crs(new_crs).total_bounds

        geom = box(*bounds)
        geom = geom.buffer(buffer_distance)
        bounds = gpd.GeoSeries(geom).total_bounds

        memstring = print_memory_allocation_from_resolution_bounds(bounds, pixel_size)
        self.iface.messageBar().pushMessage(memstring)

    def initiate_CMA_workflow(self):
        # Retrive metadata inputs
        username = self.dockwidget.UserNameLineEdit.text()
        cma_mineral = self.dockwidget.CMA_mineralLineEdit.text()
        comments = self.dockwidget.CommentsText.toPlainText()
        input_path = self.dockwidget.proj_dir_input.filePath()
        today = date.today().isoformat()

        proj_path = Path(input_path, 'CMA_' + cma_mineral)
        # Turned to true for dev. TODO this should be turned off once stable
        proj_path.mkdir(exist_ok=True)
        template_output_path = str(Path(proj_path, cma_mineral + '_template_raster.tif'))
        data_raster_path = str(Path(proj_path, cma_mineral + '_data_raster.tif'))

        # Retrieve template creation inputs
        selectedLayer = self.dockwidget.template_input.currentLayer()
        datastr = selectedLayer.source()
        pixel_size = self.dockwidget.pixel_size_input.value()
        buffer_distance = self.dockwidget.buffer_dist_spinBox.value()

        try:
            # This will be the case for geopackages, but not shapefile or geojson
            fp, layername = datastr.split('|')
            gdf = gpd.read_file(fp, layername=layername.split('=')[1])
        except ValueError:
            fp = datastr
            gdf = gpd.read_file(fp)

        box_crs = self.dockwidget.mQgsProjectionSelectionWidget.crs()
        input_crsWkt = box_crs.toWkt()
        new_crs = rio.crs.CRS.from_wkt(input_crsWkt)
        bounds = gdf.to_crs(new_crs).total_bounds

        geom = box(*bounds)
        geom = geom.buffer(buffer_distance)
        bounds = gpd.GeoSeries(geom).total_bounds
        create_template_raster_from_bounds_and_resolution(bounds=bounds, target_crs=new_crs, pixel_size=pixel_size,
                                                          output_path=template_output_path)
        shutil.copy(template_output_path, data_raster_path)

        meta_dict = {'username': username, 'mineral': cma_mineral, 'comments': comments, 'date_initiated': today,
                     'project_path': str(proj_path), 'project_CRS': str(new_crs), 'project_bounds': str(bounds),
                     'template_path': template_output_path, 'data_raster_path': data_raster_path}

        with open(Path(proj_path, 'project_metadata.json'), 'w') as f:
            json.dump(meta_dict, f)

        self.meta_data = meta_dict

    def interpolate_geochem_points(self):


        geochem_data_input = self.dockwidget.geochem_data_selection_box.currentIndex()
        interpolation_method_input = self.dockwidget.interpolation_method_box.currentIndex()
        element_input = self.dockwidget.element_selection_box.currentText()

        template_path = self.meta_data['template_path']
        data_raster_path = self.meta_data['data_raster_path']

        # Black Shale Data for devtest purposes
        # Inputs needed
        # 1) Which database
        # 2) Which interpolation method
        # 3) Which element
        # 4) Whether to use all points or a geographic subsest
        # 4.1) if yes which extent # Will use current window for selection for now
        # 5) Template raster path (or meta)
        # 6) an output path (or inferred)

        if geochem_data_input == 0:
            print('using black shales database')
            gdf, element_col = prep_black_shales(template_path, element_input)
        elif geochem_data_input == 1:
            print("using NGDB rock")
        else:
            print('no valid selection')


        output_file_path, message = interpolate_gdf_value(gdf, element_col, self.meta_data['template_path'])

        res = QgsRasterLayer(output_file_path, 'Interpolated_Layer')
        QgsProject.instance().addMapLayer(res)

    def addLayerDialog(self):
        popup = AddRasterLayer(self)
        popup.exec_()

    def set_project_json(self):
        proj_path = self.dockwidget.resume_json_file_input.filePath()
        with open(Path(proj_path), 'r') as f:
            self.meta_data = json.loads(f.read())

        message = f"Project files loaded from: {proj_path}"
        self.iface.messageBar().pushMessage(message)

    def RefreshList(self, elem):
        listWidget = self.dockwidget.listWidget
        listWidget.addItem(elem)

    def process_add_raster_list(self):
        template_path = self.meta_data['template_path']
        data_raster_path = self.meta_data['data_raster_path']

        num_threads = self.dockwidget.num_threads_resamp_spinBox.value()
        input_raster_list = self.pathlist
        method_list = self.methodlist
        description_list = self.desclist

        # turn method string to resampling type using the dictionary in helperFuncs
        riomethod_list = [resampling_dict.get(m, m) for m in method_list]

        resampled_arrays = match_and_stack_rasters(template_path, input_raster_list, riomethod_list, num_threads=num_threads)
        add_matched_arrays_to_data_raster(data_raster_path, resampled_arrays, description_list)

        self.dockwidget.listWidget.clear()

        message = "Layers appended to the raster data stack"
        self.iface.messageBar().pushMessage(message)

    def rasterize_training(self):
        selectedLayer = self.dockwidget.training_layer_combo_box.currentLayer()
        datastr = selectedLayer.source()
        buffer_distance = self.dockwidget.training_buffer_dist.value()

        # TODO update training rasterization to take do the values by attribute
        field = self.dockwidget.trainingFieldComboBox.currentField()

        try:
            # This will be the case for geopackages, but not shapefile or geojson
            fp, layername = datastr.split('|')
            training_gdf = gpd.read_file(fp, layername=layername.split('=')[1])
        except ValueError:
            fp = datastr
            training_gdf = gpd.read_file(fp)

        training_raster_output_path = str(Path(self.meta_data['project_path'], 'training_raster.tif'))

        # TODO add to TOC

        message = training_vector_rasterize(training_gdf, self.meta_data['template_path'], training_raster_output_path, buffer_distance)
        self.iface.messageBar().pushMessage(message)

    def threshold_inference(self):
        # Get inputs from GUI
        prob_path = self.dockwidget.prob_layer_box.currentLayer().source()
        uncert_path = self.dockwidget.uncert_layer_box.currentLayer().source()
        prob_cut = self.dockwidget.probability_thresh_box.value()
        cert_cut = self.dockwidget.uncert_thresh_box.value()
        remove_hanging = self.dockwidget.remove_hanging_check.isChecked()
        to_polys = self.dockwidget.to_poly_check.isChecked()

        # run function
        output = threshold_inference(prob_path, uncert_path, prob_cut, cert_cut, remove_hanging, to_polys)

        # Set up for saving and adding to TOC
        root = QgsProject.instance().layerTreeRoot()
        if root.findGroup('Inference') == None:
            inference_group = root.insertGroup(0, 'Inference')
        else:
            inference_group = root.findGroup('Inference')
        r_ds = gdal.Open(prob_path)
        geot = r_ds.GetGeoTransform()
        r_proj = r_ds.GetProjection()
        savedLayer = gdalSave1('Threshold', output[0], gdal.GDT_Byte, geot, r_proj, 0)
        addRFconfLayer(savedLayer, f"Inference_Cutoff_prob_{format(prob_cut, '.2f')}_uncert_{format(cert_cut, '.2f')}", inference_group)

        if to_polys:
            print('raster and vector')
            tfol = tempfile.mkdtemp()  # maybe this should be done globally at the init??
            outpath = tfol + '/Threshold_Inference.shp'
            output[1].to_file(outpath)
            addVectorLayer(outpath, f"Inference Polys_prob_{format(prob_cut, '.2f')}_uncert_{format(cert_cut, '.2f')}", inference_group)

        self.iface.messageBar().pushMessage('Files Added')

    def distance_to_features_raster(self):
        selectedLayer = self.dockwidget.proximity_layer_box.currentLayer()
        withSelected = self.dockwidget.withSelectedcheckBox_prox.isChecked()

        gdf = qgs_features_to_gdf(selectedLayer, selected=withSelected)
        output_file_path, message = vector_proximity_raster(gdf, self.meta_data['template_path'])

        res = QgsRasterLayer(output_file_path, 'Proximity_Layer')
        QgsProject.instance().addMapLayer(res)

        self.iface.messageBar().pushMessage(message)






    def runButtons(self):
        self.dockwidget.refresh_col1_button.clicked.connect(self.RefreshBandSelection)
        self.dockwidget.refreshTableButton.clicked.connect(self.RefreshTable)
        self.dockwidget.MakeTempLayer.clicked.connect(self.makeTempLayer)
        self.dockwidget.exportTrainingButton.clicked.connect(self.saveTrainingDataOut)
        self.dockwidget.export_errMat_button.clicked.connect(self.export_conf_mat)

        self.dockwidget.ButRun_ZS.clicked.connect(self.applyStdReturnMatchLayer)
        self.dockwidget.get_ststs_button.clicked.connect(self.fillStatBoxFromSelectedPoly)
        self.dockwidget.ApplyStdevMatch.clicked.connect(self.constantSTdevMatch)
        self.dockwidget.evaluatePolygons.clicked.connect(self.evaluteTrainingPolygons)
        self.dockwidget.MinMaxMatch_button.clicked.connect(self.returnBoreMatch)


        self.dockwidget.RunKmeansButton.clicked.connect(self.selectKmeansData)
        self.dockwidget.MapClustersButton.clicked.connect(self.NewMapClusters)
        self.dockwidget.mapSubClustersButton.clicked.connect(self.mapMaskedClusters)
        self.dockwidget.DetectNumClusters.clicked.connect(self.DetectNumberClusters)

        self.dockwidget.generate_plot_button.clicked.connect(self.runPCAplot)
        self.dockwidget.PlotData.clicked.connect(self.makeSpectralPlot)
        self.dockwidget.summary_button.clicked.connect(self.summarize_training)

        self.dockwidget.trainRFmodButton.clicked.connect(self.selectRFtrainPixel)
        self.dockwidget.mapPredsButton.clicked.connect(self.selectRFapplyPixel)

        self.dockwidget.randSelButton.clicked.connect(self.selectRFtrainPoly)
        self.dockwidget.mapMultiModelMode.clicked.connect(self.selectRFapplyPoly)

        self.dockwidget.gather_pt_data_button.clicked.connect(self.sample_raster_at_points)
        self.dockwidget.train_svm_button.clicked.connect(self.trainOneClassSVM)
        self.dockwidget.map_svm_button.clicked.connect(self.mapSVMscores)

        self.dockwidget.check_size_button.clicked.connect(self.print_estimated_size)
        self.dockwidget.make_template_raster_button.clicked.connect(self.initiate_CMA_workflow)

        self.dockwidget.do_interpolate_button.clicked.connect(self.interpolate_geochem_points)

        self.dockwidget.addLayerButton.clicked.connect(self.addLayerDialog)
        self.dockwidget.add_rasters_to_stack_button.clicked.connect(self.process_add_raster_list)

        self.dockwidget.resume_jsonProj_button.clicked.connect(self.set_project_json)

        self.dockwidget.rasterize_training_button.clicked.connect(self.rasterize_training)

        self.dockwidget.threshold_inference_button.clicked.connect(self.threshold_inference)

        self.dockwidget.create_proximity_layer_button.clicked.connect(self.distance_to_features_raster)

